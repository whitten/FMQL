<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2011.1.2 (Build 701)" ts="2014-04-01 02:29:23">

<Routine name="FMQLDATA" type="MAC" languagemode="0" timestamp="63266,3996.134921"><![CDATA[
FMQLDATA ;CG/CD - Caregraf - FMQL Data Query Processor; 11/25/2013  11:30
 ;;1.1b;FMQLQP;;Nov 25th, 2013
 ;
 ;
 ; FMQL Data Query Processor
 ;
 ; For queries for data. Peer of FMQLSCH
 ;
 ; FMQL Query Processor (c) Caregraf 2010-2013 AGPL
 ;
 ;
 ;
DESONE(REPLY,PARAMS) ;
 I '$D(PARAMS("TYPE")) D ERRORREPLY^FMQLJSON(REPLY,"Type Not Specified") Q
 I '$D(PARAMS("ID")) D ERRORREPLY^FMQLJSON(REPLY,"ID Not Specified") Q
 ; CNODESTOP defaults to 10 unless set explicitly
 N CNODESTOP S CNODESTOP=$S($D(PARAMS("CNODESTOP")):$G(PARAMS("CNODESTOP")),1:10)
 N NTYPE S NTYPE=$TR(PARAMS("TYPE"),"_",".")
 N FLINF D BLDFLINF^FMQLUTIL(NTYPE,.FLINF)
 I $D(FLINF("BAD")) D ERRORREPLY^FMQLJSON(REPLY,FLINF("BAD")) Q
 I '$D(FLINF("GL")) D ERRORREPLY^FMQLJSON(REPLY,"Can Only Describe a Global") Q
 I '$D(@FLINF("ARRAY")@(PARAMS("ID"),0)) D ERRORREPLY^FMQLJSON(REPLY,"No such identifier for type "_PARAMS("TYPE")) Q
 D REPLYSTART^FMQLJSON(REPLY)
 D LISTSTART^FMQLJSON(REPLY,"results") ; TBD: remove for new JSON
 D ONEOFTYPE(REPLY,.FLINF,FLINF("ARRAY"),PARAMS("ID"),CNODESTOP)
 D LISTEND^FMQLJSON(REPLY)
 ; the query as args
 D DICTSTART^FMQLJSON(REPLY,"fmql")
 D DASSERT^FMQLJSON(REPLY,"OP","DESCRIBE")
 D DASSERT^FMQLJSON(REPLY,"URI",FLINF("EFILE")_"-"_PARAMS("ID"))
 D DASSERT^FMQLJSON(REPLY,"CSTOP",CNODESTOP)
 D DICTEND^FMQLJSON(REPLY)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
 ;
ALL(REPLY,PARAMS) ;
 N FLINF,BPERR,PFLINF,PID,IENA,LIMIT,OFFSET,NOIDXMX,ORDERBY,AFTERIEN,CNODESTOP,TOX,CNT
 I '$D(PARAMS("TYPE")) D ERRORREPLY^FMQLJSON(REPLY,"Type Not Specified") Q
 S FILE=$TR(PARAMS("TYPE"),"_",".")
 D BLDFLINF^FMQLUTIL(FILE,.FLINF)
 I $D(FLINF("BAD")) D ERRORREPLY^FMQLJSON(REPLY,FLINF("BAD")) Q
 I '$D(FLINF("GL")) D  ; Handle Describe or Count of contained nodes.
 . I '$D(PARAMS("IN")) S BPERR="Missing: Contained Node Selection requires 'IN'" Q
 . D PARSEURL^FMQLUTIL(PARAMS("IN"),.PFLINF,.PID)
 . I '$D(PID) S BPERR="Bad Value: 'IN' requires ID" Q
 . I '$D(PFLINF("GL")) S BPERR="Bad Value: 'IN' must be a global type" Q
 . I PFLINF("FILE")'=FLINF("PARENT") S BPERR="Bad Value: CNode parent must be in 'IN'" Q
 . S IENA=$NA(@PFLINF("ARRAY")@(PID,FLINF("PLOCSUB")))
 E  S IENA=""
 I $D(BPERR) D ERRORREPLY^FMQLJSON(REPLY,BPERR) Q
 ; Defaults of -1,0,-1 for no LIMIT, no offset, no max cut off if no IDX, 
 S LIMIT=$S($G(PARAMS("LIMIT"))?0.1"-"1.N:PARAMS("LIMIT"),1:-1)
 S OFFSET=$S($G(PARAMS("OFFSET"))?1.N:PARAMS("OFFSET"),1:0)
 S NOIDXMX=$S($G(PARAMS("NOIDXMX"))?1.N:PARAMS("NOIDXMX"),1:-1)
 S ORDERBY=$G(PARAMS("ORDERBY"))
 S AFTERIEN=$G(PARAMS("AFTERIEN"))  ; float value enforced above this pt
 I AFTERIEN'="" S OFFSET=0  ; Make sure AFTERIEN takes precedence
 ; Forcing default CNODESTOP to be 10
 I PARAMS("OP")="DESCRIBE" S CNODESTOP=$S($D(PARAMS("CNODESTOP")):$G(PARAMS("CNODESTOP")),1:10)
 ; Default value is "" for COUNT
 S TOX=$S((PARAMS("OP")="SELECT"):"D JSEL^FMQLDATA(REPLY,.FLINF,FAR,IEN,.PARAMS)",(PARAMS("OP")="DESCRIBE"):"D JDES^FMQLDATA(REPLY,.FLINF,FAR,IEN,CNODESTOP,.PARAMS)","1":"")
 D REPLYSTART^FMQLJSON(REPLY)
 D LISTSTART^FMQLJSON(REPLY,"results")
 S CNT=$$XONFL^FMQLUTIL(.FLINF,$G(PARAMS("FILTER")),IENA,LIMIT,OFFSET,AFTERIEN,ORDERBY,NOIDXMX,TOX,.PARAMS)
 D LISTEND^FMQLJSON(REPLY)
 ; Note: if problem listing (no indexed filter), CNT<0
 D DASSERT^FMQLJSON(REPLY,"count",CNT)
 ; TBD: how to record NOIDXMX?
 D DICTSTART^FMQLJSON(REPLY,"fmql")
 D DASSERT^FMQLJSON(REPLY,"OP",PARAMS("OP"))
 D DASSERT^FMQLJSON(REPLY,"TYPELABEL",FLINF("LABEL"))
 D DASSERT^FMQLJSON(REPLY,"TYPE",FLINF("EFILE"))
 I PARAMS("OP")'="COUNT" D
 . D DASSERT^FMQLJSON(REPLY,"LIMIT",LIMIT)
 . ; TODO: handle alternative of AFTERIEN for OFFSET above and do one or other
 . I $D(PARAMS("AFTERIEN")) D DASSERT^FMQLJSON(REPLY,"AFTERIEN",PARAMS("AFTERIEN"))
 . E  D DASSERT^FMQLJSON(REPLY,"OFFSET",OFFSET)
 I $D(PARAMS("FILTER")) D DASSERT^FMQLJSON(REPLY,"FILTER",PARAMS("FILTER"))
 ; Only for DESCRIBE
 I $D(CNODESTOP) D DASSERT^FMQLJSON(REPLY,"CSTOP",CNODESTOP)
 D DICTEND^FMQLJSON(REPLY)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
 ;
 ; Build JSON for one selection
 ; - FAR = FLINF("ARRAY") for Global; FAR = Qualified location for CNode
 ; Note: supports only top level CNodes
 ; Note: "g"]"H" in MUMPS ie. lower case follows upper case. This means
 ;       selection order is case sensitive. This may be unexpected.
 ; 
 ; Note: MAY DEPRECATE AS SBYPRED is more useful, DESCRIBE CSTOP 0 is succinct enough
 ; or expand to take a list of predicates.
 ; 
 ; 
JSEL(REPLY,FLINF,FAR,IEN,PARAMS) ;
 D DICTSTART^FMQLJSON(REPLY)
 ; FID=IEN for Globals. Only qualify for CNodes
 ; - replace for unusual IENS in .11 etc.
 N FID S FID=$S('$D(FLINF("GL")):IEN_"_"_$QS(FAR,$QL(FAR)-1),1:IEN)
 D IDFIELD(.FLINF,FAR,IEN,FID)
 I $D(PARAMS("FIELD")) D
 . N FDINF D BLDFDINF^FMQLUTIL(.FLINF,PARAMS("FIELD"),.FDINF)
 . Q:$D(FDINF("BAD"))  ; TBD: centralize
 . Q:FDINF("TYPE")=9  ; Don't allow CNode selection this way. Force "IN".
 . Q:FDINF("TYPE")=11  ; For now, don't allow .001 as most not explicitly exposed
 . D ONEFIELD(FAR,IEN,.FDINF)
 D DICTEND^FMQLJSON(REPLY)
 Q
 ;
 ;
 ; Same as JSEL except returns full description
JDES(REPLY,FLINF,FAR,IEN,CNODESTOP,PARAMS) ;
 ; Last Subscript for CNode
 N ID S ID=$S('$D(FLINF("GL")):IEN_"_"_$QS(FAR,$QL(FAR)-1),1:IEN)
 D ONEOFTYPE(REPLY,.FLINF,FAR,ID,CNODESTOP)
 Q
 ;
 ;
ONEOFTYPE(REPLY,FLINF,FAR,FID,CNODESTOP) ;
 N ID S ID=$P(FID,"_") ; Allow for CNode
 Q:$P($G(@FAR@(ID,0)),"^")=""  ; All need an .01 field
 D DICTSTART^FMQLJSON(REPLY)
 N FIELD S FIELD=0 F  S FIELD=$O(^DD(FLINF("FILE"),FIELD)) Q:FIELD'=+FIELD  D
 . N FDINF D BLDFDINF^FMQLUTIL(.FLINF,FIELD,.FDINF)
 . Q:$D(FDINF("BAD"))
 . I FDINF("TYPE")=9 D  ; TBD: loop with walkers and B Index
 . . Q:'$D(@FAR@(ID,FDINF("LOCSUB")))
 . . N NFAR S NFAR=$NA(@FAR@(ID,FDINF("LOCSUB")))
 . . ; Pharma+ case: CNode location but no list params in 0 node
 . . Q:$P($G(@NFAR@(0)),"^",4)=""
 . . ; Using $O to skip missing CNodes, starting after 1 etc.
 . . N BFLINF D BLDFLINF^FMQLUTIL(FDINF("BFILE"),.BFLINF)
 . . ; Ignore if over CNODESTOP
 . . N CCNT S CCNT=0
 . . N BID S BID=0 F  S BID=$O(@NFAR@(BID)) Q:BID'=+BID!(CCNT=CNODESTOP)  S CCNT=CCNT+1
 . . I CCNT'=CNODESTOP  D
 . . . Q:CCNT=0  ; Don't mark empty bnodes (Pharma et al)
 . . . N ISLIST S ISLIST=$S(BFLINF("NOFIELDS")=1:1,1:0)
 . . . D BNLISTSTART^FMQLJSON(REPLY,BFLINF("EFILE"),FDINF("LABEL"),FIELD,ISLIST)
 . . . ; No need for NFAR or BFLINF if FLINF (even if CNode) supports ARRAY
 . . . N BID S BID=0 F  S BID=$O(@NFAR@(BID)) Q:BID'=+BID  D
 . . . . D ONEOFTYPE(REPLY,.BFLINF,NFAR,BID_"_"_FID,CNODESTOP)
 . . . D BNLISTEND^FMQLJSON(REPLY)
 . . E  D BNLISTSTOPPED^FMQLJSON(REPLY,BFLINF("EFILE"),FDINF("LABEL"),FIELD)
 . E  D
 . . I FDINF("FIELD")=.001 D OO1FIELD(ID,.FDINF) Q
 . . D ONEFIELD(FAR,ID,.FDINF) D:FDINF("FIELD")=.01 IDFIELD(.FLINF,FAR,ID,FID)
 ; TBD: properly count SLABS ala other CNodes
 I FLINF("FILE")="63.04",CNODESTOP>0,^TMP($J,"NS")="VS" D BLDBNODES^FMQLSLAB(FAR,FID)
 D DICTEND^FMQLJSON(REPLY)
 Q
 ;
 ;
 ; ID is special. Derived from resolving the .01 field.
 ;
IDFIELD(FLINF,FAR,ID,FID) ;
 ; TBD: is this redundant?
 N O1L S O1L=$P($G(@FAR@(ID,0)),"^")
 ; All records should have a value for .01. TBD: check above.
 ; Saw bug in RPMS (9001021) where index has "^" as name and 0 is "^".
 Q:O1L=""
 N FDINF D BLDFDINF^FMQLUTIL(.FLINF,.01,.FDINF)  ; Assume ok. FLINF checked
 N EVALUE S EVALUE=$$GETEVAL^FMQLUTIL(.FDINF,O1L)
 N PVALUE S PVALUE=$TR(FLINF("FILE"),".","_")_"-"_FID
 N PLABEL S PLABEL=$TR(FLINF("LABEL"),"/","_")_"/"_$TR(EVALUE,"/","_")
 ; SAMEAS ONLY FOR GLOBALS
 N PSAMEAS I $D(FLINF("GL")),$L($T(RESOLVE^FMQLSSAM)) D RESOLVE^FMQLSSAM(FLINF("FILE"),ID,PLABEL,.PSAMEAS)
 D ASSERT^FMQLJSON(REPLY,"URI",".01","7",PVALUE,PLABEL,.PSAMEAS)
 Q
 ;
 ;
 ; Build JSON for one non-CNode Field
 ;
 ; Assume: FDINF is good
 ;
ONEFIELD(FAR,ID,FDINF) ;
 Q:FDINF("TYPE")=6  ; Computed - includes .001
 Q:'$D(@FAR@(ID,FDINF("LOCSUB")))
 I FDINF("TYPE")=5 D
 . ; Pharma+ case: WP location but no entries (ala special case for 9)
 . ; TBD: "" only entry. Seen in RAD, P/H. 
 . Q:'$D(@FAR@(ID,FDINF("LOCSUB"),1))
 . D WPASTART^FMQLJSON(REPLY,FDINF("LABEL"),FDINF("FIELD"))
 . F WPR=1:1 Q:'$D(@FAR@(ID,FDINF("LOCSUB"),WPR))  D
 . . D WPALINE^FMQLJSON(REPLY,@FAR@(ID,FDINF("LOCSUB"),WPR,0))
 . D WPAEND^FMQLJSON(REPLY)
 E  D
 . ; Check as sub values may exist but not the value indicated. 
 . ; Saw WP field's location overloaded for another field 
 . ; (RPMS:811.8 vs VistA's which is ok)
 . Q:$G(@FAR@(ID,FDINF("LOCSUB")))=""
 . N LOCSUB S LOCSUB=@FAR@(ID,FDINF("LOCSUB"))
 . ; For $E values, don't just take the $E limit.
 . N IVALUE S IVALUE=$S($D(FDINF("LOCPOS")):$P(LOCSUB,"^",FDINF("LOCPOS")),1:LOCSUB) Q:IVALUE=""
 . ; Note: issue with EVALUE here before type specific checks is that EVAL must dup the checks
 . N EVALUE S EVALUE=$$GETEVAL^FMQLUTIL(.FDINF,IVALUE)
 . I FDINF("TYPE")=7 D
 . . N PFLINF D BLDFLINF^FMQLUTIL(FDINF("PFILE"),.PFLINF)
 . . Q:$D(PFLINF("BAD"))
 . . S PVALUE=$TR(PFLINF("FILE"),".","_")_"-"_IVALUE
 . . S PLABEL=$TR(PFLINF("LABEL"),"/","_")_"/"_$TR(EVALUE,"/","_")
 . . N PSAMEAS I $L($T(RESOLVE^FMQLSSAM)) D RESOLVE^FMQLSSAM(PFLINF("FILE"),IVALUE,PLABEL,.PSAMEAS)
 . . D ASSERT^FMQLJSON(REPLY,FDINF("LABEL"),FDINF("FIELD"),"7",PVALUE,PLABEL,.PSAMEAS)
 . E  I FDINF("TYPE")=8 D
 . . N PID S PID=$P(IVALUE,";")
 . . Q:PID'=+PID  ; Corrupt pointer
 . . Q:$P(IVALUE,";",2)=""  ; Corrupt pointer
 . . N LOCZ S LOCZ="^"_$P(IVALUE,";",2)_"0)"  ; 0 has file's description
 . . Q:'$D(@LOCZ)
 . . N PFI S PFI=@LOCZ
 . . N PFILE S PFILE=+$P(PFI,"^",2)
 . . N PFLBL S PFLBL=$TR($P(PFI,"^",1),"/","_")
 . . S PVALUE=$TR(PFILE,".","_")_"-"_PID
 . . S PLABEL=$TR(PFLBL,"/","_")_"/"_$TR(EVALUE,"/","_")
 . . N PSAMEAS I $L($T(RESOLVE^FMQLSSAM)) D RESOLVE^FMQLSSAM(PFILE,PID,PLABEL,.PSAMEAS)
 . . D ASSERT^FMQLJSON(REPLY,FDINF("LABEL"),FDINF("FIELD"),"8",PVALUE,PLABEL,.PSAMEAS)
 . E  D ASSERT^FMQLJSON(REPLY,FDINF("LABEL"),FDINF("FIELD"),FDINF("TYPE"),EVALUE)
 Q
 ;
 ;
 ; .001 is special: its value is the IEN of a record. Nothing is stored inside the file.
 ; Some values (Date, Pointer) should be first class fields.
 ;
OO1FIELD(ID,FDINF)  ;
 N PFLINF,PVALUE,PLABEL,EVALUE,PSAMEAS
 Q:FDINF("TYPE")'=11
 ; IEN is a pointer
 I $D(FDINF("PFILE")) D
 . D BLDFLINF^FMQLUTIL(FDINF("PFILE"),.PFLINF)
 . Q:$D(PFLINF("BAD"))
 . S PVALUE=$TR(PFLINF("FILE"),".","_")_"-"_ID
 . S FDINF("TYPE")=7  ; Overload .001 defn as a pointer
 . S EVALUE=$$GETEVAL^FMQLUTIL(.FDINF,ID)
 . S PLABEL=$TR(PFLINF("LABEL"),"/","_")_"/"_$TR(EVALUE,"/","_")
 . I $L($T(RESOLVE^FMQLSSAM)) D RESOLVE^FMQLSSAM(PFLINF("FILE"),ID,PLABEL,.PSAMEAS)
 . D ASSERT^FMQLJSON(REPLY,FDINF("LABEL"),FDINF("FIELD"),FDINF("TYPE"),PVALUE,PLABEL,.PSAMEAS)
 ; IEN is a date - TODO: issue of DX vs D?
 E  I FDINF("FLAGS")["D" D
 . S FDINF("TYPE")=1
 . S EVALUE=$$GETEVAL^FMQLUTIL(.FDINF,ID)
 . D ASSERT^FMQLJSON(REPLY,FDINF("LABEL"),FDINF("FIELD"),FDINF("TYPE"),EVALUE)
 S FDINF("TYPE")=11
 Q
 ;
 ;
 ; CNTREFS
 ;
 ; Ex/ COUNTREFS 2-9 - count the referrers to entry 9 in file 2
 ;
 ; Unlike generic graph stores that are specialized for 
 ; "SELECT * FILTER(*=2-9)", the strongly typed FileMan
 ; has no central index of referrents. As a result, such
 ; a general query is slow and unnatural. However, a querier
 ; still needs to know about the graph a file entry appears in.
 ; 
 ; This operation is a compromise. It counts references from
 ; appropriately indexed referrers. These counts provide a
 ; starting off point for exploring a file entry's graph.
 ;
 ; In: type, id
 ; Out: total, count per file/field combo
 ;
 ; NB: NOIDXMX is key here. If set too low then certain referrer
 ; grabs will go far too long. This is set in the Python query
 ; processor.
 ;
CNTREFS(REPLY,PARAMS) ;
 I '$D(PARAMS("TYPE")) D ERRORREPLY^FMQLJSON(REPLY,"Type Not Specified") Q
 I '$D(PARAMS("ID")) D ERRORREPLY^FMQLJSON(REPLY,"ID Not Specified") Q
 N NTINF D BLDFLINF^FMQLUTIL(PARAMS("TYPE"),.NTINF)
 I $D(NTINF("BAD")) D ERRORREPLY^FMQLJSON(REPLY,NTINF("BAD")) Q
 I '$D(@NTINF("ARRAY")@(PARAMS("ID"),0)) D ERRORREPLY^FMQLJSON(REPLY,"No such identifier for type "_PARAMS("TYPE")) Q
 N TARGET S TARGET=NTINF("EFILE")_"-"_PARAMS("ID")
 ; NOIDXMX is important. Otherwise the unimportant will take time.
 N NOIDXMX S NOIDXMX=$G(PARAMS("NOIDXMX"))
 S:(NOIDXMX'=+NOIDXMX) NOIDXMX=-1
 N TCNT S TCNT=0
 D REPLYSTART^FMQLJSON(REPLY)
 D LISTSTART^FMQLJSON(REPLY,"results")
 N RFL ; Order referrer types by name
 S FILE="" F  S FILE=$O(^DD(NTINF("FILE"),0,"PT",FILE)) Q:FILE'=+FILE  D
 . N FLINF D BLDFLINF^FMQLUTIL(FILE,.FLINF)
 . Q:($D(FLINF("BAD"))!$D(FLINF("PARENT")))
 . S RFL(FLINF("LABEL"),FILE)=""
 ; Walk referring files in order (know ok as orderer catches bad files)
 S FILELABEL="" F  S FILELABEL=$O(RFL(FILELABEL)) Q:FILELABEL=""  D
 . S FILE="" F  S FILE=$O(RFL(FILELABEL,FILE)) Q:FILE=""  D
 . . N FLINF D BLDFLINF^FMQLUTIL(FILE,.FLINF)
 . . ; Q:FLINF("FMSIZE")<1  ; surely empty files aren't costly
 . . N FIELD S FIELD="" F  S FIELD=$O(^DD(NTINF("FILE"),0,"PT",FILE,FIELD)) Q:FIELD'=+FIELD  D
 . . . N FDINF D BLDFDINF^FMQLUTIL(.FLINF,FIELD,.FDINF)
 . . . I $D(FDINF("BAD")) Q
 . . . I FDINF("TYPE")'=7 Q  ; PTR only for now (no vptr)
 . . . N FLT S FLT=FIELD_"="_NTINF("FILE")_"-"_PARAMS("ID")
 . . . N CNT S CNT=$$XONFL^FMQLUTIL(.FLINF,FLT,"",-1,0,"","",NOIDXMX,"")
 . . . Q:CNT=-1  ; means no idx max exceeded.
 . . . Q:CNT=0 
 . . . D DICTSTART^FMQLJSON(REPLY)
 . . . N FLDLABEL S FLDLABEL=FDINF("LABEL") ; Add predicate
 . . . D DASSERT^FMQLJSON(REPLY,"file",FLINF("EFILE"))
 . . . D DASSERT^FMQLJSON(REPLY,"fileLabel",FILELABEL)
 . . . D DASSERT^FMQLJSON(REPLY,"field",FIELD)
 . . . D DASSERT^FMQLJSON(REPLY,"fieldLabel",FDINF("PRED"))
 . . . D DASSERT^FMQLJSON(REPLY,"count",CNT)
 . . . D DICTEND^FMQLJSON(REPLY)
 . . . S TCNT=TCNT+CNT
 D LISTEND^FMQLJSON(REPLY)
 D DASSERT^FMQLJSON(REPLY,"total",TCNT)
 D DICTSTART^FMQLJSON(REPLY,"fmql")
 D DASSERT^FMQLJSON(REPLY,"OP","COUNT REFS")
 D DASSERT^FMQLJSON(REPLY,"URI",TARGET)
 D DICTEND^FMQLJSON(REPLY)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
]]></Routine>


<Routine name="FMQLFILT" type="MAC" languagemode="0" timestamp="63152,35757.448477"><![CDATA[
FMQLFILT ;CG/CD - Caregraf - FMQL Filter Handling; 07/12/2013  11:30
 ;;1.0;FMQLQP;;July 12th,2012
 ;
 ;
 ;
 ; FMQL Filters
 ; 
 ; Parse and Apply filters
 ; 
 ; FMQL Query Processor (c) Caregraf 2010-2013 AGPL
 ;
 ; TBD:
 ; - remove support for &: only &&
 ; - force all values to be quoted. Must be 'X' or "X"
 ; - remove need for \& inside quotes
 ;
 ;
 ;
 ; Simple & sequence of X op Y and bound(X)
 ;
 ; Note: must be careful with MUMPS evaluation precedence - lot's of brackets
 ;
FLTTOM(FLINF,FLT,IENA) ;
 Q:$D(FLINF("BAD")) "0"
 N FLTP,FLTN,TST S FLTN=1,TST="("
 ; V0.9: temp support for & while allowing missing quotes
 S FLT=$$ESCAND(FLT) ; Escape & inside
 ; V0.9. Moving to &&. Still support & for now
 N AND S AND=$S(FLT["&&":"&&","1":"&")
 F  S FLTP=$P(FLT,AND,FLTN) Q:FLTP=""  D
 . I FLTN>1 S TST=TST_"&"
 . S FLTN=FLTN+1
 . I $F(FLTP,"bound") S TST=TST_$$FLTBOUNDTOM(.FLINF,FLTP,$G(IENA))
 . E  S TST=TST_$$FLTLRTOM(.FLINF,$TR(FLTP,$C(0),"&"),$G(IENA))
 Q TST_")"
 ; 
 ;
 ; Create executable expression from FMQL "X OP Y" filter element
 ;
 ; Arguments:
 ; - FLINF
 ; - FLT: the LVAL OP RVALUE filter
 ; - IENA mandatory for CNodes
 ; 
FLTLRTOM(FLINF,FLT,IENA) ;
 N OP S OP=$S($F(FLT,"="):"=",$F(FLT,"["):"[",$F(FLT,">"):">",$F(FLT,"<"):"<",1:"")
 Q:OP="" "0"
 N FIELD S FIELD=$P(FLT,OP)
 N FDINF D BLDFDINF^FMQLUTIL(.FLINF,FIELD,.FDINF)
 Q:$D(FDINF("BAD")) "0"
 ; Take val from single quoted values after op
 N VAL S VAL=$P(FLT,OP,2)
 ; TBD: move to mandatory use of ' for values. Opt now for v0.8 compat
 ; Not using pattern. Allow quotes inside. Just catch at end.
 N QUOTE S QUOTE=$S($E(VAL,1)="'":"'",1:"""")
 ; Allow no quotes or ' or "
 I $E(VAL,1)=QUOTE,$E(VAL,$L(VAL))=QUOTE S VAL=$E(VAL,2,$L(VAL)-1)
 I OP=">",VAL'=+VAL S OP="]"  ; use order operator for non numeric > thans. TBD: what of <?
 Q:FDINF("TYPE")=8 "0"  ; not supporting VPTR yet
 S:FDINF("TYPE")=7 VAL=$P(VAL,"-",2)  ; remove file type if pointer
 S:FDINF("TYPE")=1 VAL=$$MAKEFMDATE^FMQLUTIL(VAL)  ; from FMQL to FM date
 N FAR S FARNA=$S($D(FLINF("GL")):$NA(FLINF("ARRAY")),"1":$NA(IENA))
 S LVAL="$P($G(@"_FARNA_"@(IEN,"""_FDINF("LOCSUB")_""")),""^"","_FDINF("LOCPOS")_")"
 ; One special case: remove file type if pointer. Second is date. Will do later.
 N MFLT S MFLT="("_LVAL_OP_""""_VAL_""")"
 Q MFLT
 ;
 ;
 ; Key aspect of FileMan (and sparcely populated stores in general). Optional
 ; fields don't get default values. One key filter is to check if a field has
 ; a value - is a field 'bound'?
 ;
FLTBOUNDTOM(FLINF,FLT,IENA) ;
 N FIELD S FIELD=$P($P(FLT,"(",2),")")
 N FDINF D BLDFDINF^FMQLUTIL(.FLINF,FIELD,.FDINF)
 Q:$D(FDINF("BAD")) "0"
 N NOT S NOT=$S($F(FLT,"!"):"",1:"'")
 N FAR S FARNA=$S($D(FLINF("GL")):$NA(FLINF("ARRAY")),"1":$NA(IENA))
 ; CNode special. Bound if entries: ^LR(4,"CH",0)="^63.04D^38^38"
 ; Assume if 0 filled in then there are.
 Q:FDINF("TYPE")=9 "($G(@"_FARNA_"@(IEN,"""_FDINF("LOCSUB")_""",0))"_NOT_"="""")"
 Q "($P($G(@"_FARNA_"@(IEN,"""_FDINF("LOCSUB")_""")),""^"","_FDINF("LOCPOS")_")"_NOT_"="""")"
 ;
 ;
 ; Return Index of the filter. Without this, every filtered query becomes 
 ; a linear search.
 ;
 ; Note: Globals only
 ;
FLTIDX(FLINF,FLT,IDXA,IDXSTART) ;
 Q:'$D(FLINF("GL"))
 N FLTP,FLTN
 S FLTN=1,IDXA="",IDXSTART=""
 S FLT=$$ESCAND(FLT) ; Escape inner &
 F  S FLTP=$P(FLT,"&",FLTN) Q:((FLTP="")!(IDXA'=""))  D
 . S FLTN=FLTN+1
 . Q:$F(FLTP,"bound")
 . N OP S OP=$S($F(FLT,"="):"=",$F(FLT,">"):">",1:"") Q:OP=""  ; =, > are only options
 . N FIELD S FIELD=$P(FLTP,OP)
 . N FDINF D BLDFDINF^FMQLUTIL(.FLINF,FIELD,.FDINF)
 . Q:$D(FDINF("BAD"))  ; Bad field
 . Q:FDINF("TYPE")=8  ; No "V" - not supporting variable pointers for now
 . N IDX S IDX=$$FIELDIDX^FMQLUTIL(FLINF("FILE"),FIELD)  ; TBD: move to meta
 . I IDX'="" D
 . . N ID S ID=$P(FLTP,OP,2)
 . . S ID=$TR(ID,$C(0),"&") ; put back escaped and
 . . N QUOTE S QUOTE=$S($E(ID,1)="'":"'",1:"""")
 . . ; Allow no quotes or ' or ". V0.9, force one or the other
 . . I $E(ID,1)=QUOTE,$E(ID,$L(ID))=QUOTE S ID=$E(ID,2,$L(ID)-1)
 . . Q:ID=""  ; Go to next possibility
 . . ; S:FDINF("TYPE")=4 ID=$E(ID,1,30) ; Indexes only count the first 30
 . . S:FDINF("TYPE")=7 ID=$P(ID,"-",2) ; FileMan internal form
 . . Q:ID=""  ; Not valid pointer. Catch of IDXA will be invalid
 . . S:FDINF("TYPE")=1 ID=$$MAKEFMDATE^FMQLUTIL(ID)  ; Internal date
 . . Q:ID=""  ; Not valid date
 . . I OP="=" S IDXA=FLINF("GL")_""""_IDX_""","""_ID_""")" Q
 . . ; Must be > as only option left 
 . . ; Special: float form that holds hhmmss gives problem as
 . . ; MUMPS $O won't navigate floats ie/ get the next in order.
 . . ; Must reduce date to base and get the extact next in order
 . . ; from that.
 . . S IDXA=FLINF("GL")_""""_IDX_""")"
 . . S IDXSTART=$S(FDINF("TYPE")=1:$O(@IDXA@($E(ID,1,7))),1:ID)
 Q
 ;
 ; Manual Index finding - TBD: move to own file ala manual SSAM
MFLTIDX(FLINF,FLT,IDXA,IDXSTART) ;
 I FLINF("FILE")="100" D OFLTIDX(.FLINF,FLT,.IDXA,.IDXSTART) Q
 D RXFLTIDX(.FLINF,FLT,.IDXA,.IDXSTART)
 Q
 ;
OFLTIDX(FLINF,FLT,IDXA,IDXSTART) ;
 N FLTP,FLTN
 Q:FLINF("FILE")'="100"
 S IDXA="",IDXSTART=""
 S FLTN=1,IDXA=""
 F  S FLTP=$P(FLT,"&",FLTN) Q:FLTP=""  D
 . S FLTN=FLTN+1
 . I $F(FLTP,"bound") Q
 . N OP S OP=$S($F(FLT,"="):"=",1:"")
 . Q:OP=""
 . Q:OP'="="
 . N FIELD S FIELD=$P(FLTP,OP)
 . Q:FIELD'=".02"
 . I $P($P(FLTP,"=",2),"-")'="2" Q  ; must be patient filter for now
 . N PID S PID=$P($P(FLTP,"=",2),"-",2)
 . S IDXA="^OR(100,""AR"","""_PID_";DPT("")" Q
 Q
 ;
RXFLTIDX(FLINF,FLT,IDXA,IDXSTART) ;
 ; Rely on ^PS(55,PID,"P","A"... hidden RX index in the "P" multiple of 55
 N FLTP,FLTN
 Q:FLINF("FILE")'="52"
 S IDXA="",IDXSTART=""
 S FLTN=1,IDXA=""
 F  S FLTP=$P(FLT,"&",FLTN) Q:FLTP=""  D
 . S FLTN=FLTN+1
 . I $F(FLTP,"bound") Q
 . N OP S OP=$S($F(FLT,"="):"=",1:"")
 . Q:OP=""
 . Q:OP'="="
 . N FIELD S FIELD=$P(FLTP,OP)
 . Q:FIELD'="2"
 . I $P($P(FLTP,"=",2),"-")'="2" Q  ; must be patient filter
 . N PID S PID=$P($P(FLTP,"=",2),"-",2)
 . S IDXA="^PS(55,"_PID_",""P"",""A"")" Q
 Q
 ;
 ; Escape & as long as support quoteless assertions
 ; FLT piece with form X\&Y
 ; Crude: some combinations (leading, trailing, multiple) won't work
 ; Will go when escaping becomes unnecessary in V1.0
ESCAND(FLTE) ;
 N FLT S FLT=""
 N BIT,I S I=1
 F  S BIT=$P(FLTE,"\&",I) Q:BIT=""  D
 . S:I>1 FLT=FLT_$C(0)
 . S I=I+1
 . S FLT=FLT_BIT
 S:FLT="" FLT=EFLT
 Q FLT
 ;
]]></Routine>


<Routine name="FMQLJSON" type="MAC" languagemode="0" timestamp="63152,35801.939237"><![CDATA[
FMQLJSON ;CG/CD - Caregraf - FMQL JSON Builder; 11/26/2013  11:30
 ;;1.1.b;FMQLQP;;Nov 26th, 2013
 ;
 ; FMQL JSON Builder
 ; 
 ; A "class" for building JSON responses
 ; 
 ; FMQL Query Processor (c) Caregraf 2010-2013 AGPL
 ;
ERRORREPLY(REPLY,MSG) ;
 D REPLYSTART^FMQLJSON(.REPLY)
 D DASSERT^FMQLJSON(.REPLY,"error",MSG)
 D REPLYEND^FMQLJSON(.REPLY)
 Q
REPLYSTART(JSON) ;
 S @JSON@("INDEX")=0
 S @JSON@("OFFSET")=1
 S @JSON@(0)=""
 D PUTDATA(JSON,"{")
 S @JSON@("LSTLVL")=0
 S @JSON@("LSTLVL",0)=""
 Q
LISTSTART(JSON,LABEL) ;
 D CONTSTART(JSON,""""_LABEL_""":[")
 Q
DICTSTART(JSON,LABEL) ;
 I $D(LABEL) D CONTSTART(JSON,""""_LABEL_""":{") Q
 D CONTSTART(JSON,"{")
 Q
 ;
 ; List or Dict: both are containers that increase the 'level'. 
 ; Level monitoring comes from JSON's need for commas between multiples, something XML avoids
CONTSTART(JSON,MARK) ;
 D PUTDATA(JSON,@JSON@("LSTLVL",@JSON@("LSTLVL")))
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))=","
 S @JSON@("LSTLVL")=@JSON@("LSTLVL")+1
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))=""
 D PUTDATA(JSON,MARK)
 Q
ASSERT(JSON,FIELD,IFIELD,FMTYPE,VALUE,PLABEL,PSAMEAS) ;
 D PUTDATA(JSON,@JSON@("LSTLVL",@JSON@("LSTLVL")))
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))="," ; if next el then put a col before it
 ; TODO: change to pass FDINF which has predicate
 S PRED=$$FIELDTOPRED^FMQLUTIL(FIELD)
 D PUTDATA(JSON,""""_PRED_""":{""fmId"":"""_IFIELD_""",""fmType"":"""_FMTYPE_""",""value"":"""_$$JSONSTRING(VALUE)_"""")
 I $G(PLABEL)'="" D
 . D PUTDATA(JSON,",""type"":""uri"",""label"":"""_$$JSONSTRING(PLABEL)_"""")
 . I $D(PSAMEAS) D
 . . D PUTDATA(JSON,",""sameAs"":"""_PSAMEAS("URI")_"""")
 . . D:$D(PSAMEAS("LABEL")) PUTDATA(JSON,",""sameAsLabel"":"""_$$JSONSTRING(PSAMEAS("LABEL"))_"""")
 E  D
 . I FMTYPE="1" D PUTDATA(JSON,",""type"":""typed-literal"",""datatype"":""xsd:dateTime""") Q
 . I FMTYPE="12" D PUTDATA(JSON,",""type"":""typed-literal"",""datatype"":""xsd:boolean""") Q
 . D PUTDATA(JSON,",""type"":""literal""")
 D PUTDATA(JSON,"}")
 Q
DASSERT(JSON,LVALUE,RVALUE) ;
 D PUTDATA(JSON,@JSON@("LSTLVL",@JSON@("LSTLVL")))
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))="," ; if next el then put a col before it
 D PUTDATA(JSON,""""_LVALUE_""":"""_$$JSONSTRING(RVALUE)_"""")
 Q
VASSERT(JSON,LVALUE,VALUE) ;
 D PUTDATA(JSON,@JSON@("LSTLVL",@JSON@("LSTLVL")))
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))="," ; if next el then put a col before it
 D PUTDATA(JSON,""""_LVALUE_""":{""type"":""literal"",""value"":"""_VALUE_"""}")
 Q
WPASTART(JSON,FIELD,IFIELD) ;
 D PUTDATA(JSON,@JSON@("LSTLVL",@JSON@("LSTLVL")))
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))="," ; if next el then put a col before it
 S @JSON@("LSTLVL")=@JSON@("LSTLVL")+1
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))=""
 D PUTDATA(JSON,""""_$$FIELDTOPRED^FMQLUTIL(FIELD)_""":{""fmId"":"""_IFIELD_""",""fmType"":""5"",""type"":""typed-literal"",""datatype"":""http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral"",""value"":""")
 Q
 ;
 ; May add $$HTML^DILF escape
WPALINE(JSON,LINE) ;
 D PUTDATA(JSON,@JSON@("LSTLVL",@JSON@("LSTLVL")))
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))="\r" ; if next el then put a col before it
 D PUTDATA(JSON,$$JSONSTRING(LINE))
 Q
WPAEND(JSON) ;
 D CONTEND(JSON,"""}")
 Q
BNLISTSTART(JSON,BFL,BFDLBL,BFD,ISL) ; 
 D PUTDATA(JSON,@JSON@("LSTLVL",@JSON@("LSTLVL")))
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))=","
 S @JSON@("LSTLVL")=@JSON@("LSTLVL")+1
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))=""
 N ISLJ S ISLJ=$S($G(ISL)=1:",""list"":true",1:"")
 D PUTDATA(JSON,""""_$$FIELDTOPRED^FMQLUTIL(BFDLBL)_""":{""fmId"":"""_BFD_""",""type"":""cnodes"",""file"":"""_BFL_""""_ISLJ_",""value"":[")
 Q
BNLISTEND(JSON) ;
 D CONTEND(JSON,"]}")
 Q
BNLISTSTOPPED(JSON,BFL,BFDLBL,BFD) ;
 D PUTDATA(JSON,@JSON@("LSTLVL",@JSON@("LSTLVL")))
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))=","
 S @JSON@("LSTLVL")=@JSON@("LSTLVL")+1
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))=""
 D PUTDATA(JSON,""""_$$FIELDTOPRED^FMQLUTIL(BFDLBL)_""":{""fmId"":"""_BFD_""",""type"":""cnodes"",""stopped"":""true"",""file"":"""_BFL_"""")
 D CONTEND(JSON,"}")
 Q
DICTEND(JSON) ;
 D CONTEND(JSON,"}")
 Q
LISTEND(JSON) ;
 D CONTEND(JSON,"]")
 Q
CONTEND(JSON,MARKUP) ;
 D PUTDATA(JSON,MARKUP)
 K @JSON@("LSTLVL",@JSON@("LSTLVL"))
 S @JSON@("LSTLVL")=@JSON@("LSTLVL")-1
 Q
REPLYEND(JSON) ;
 D PUTDATA(JSON,"}")
 K @JSON@("LSTLVL")
 K @JSON@("INDEX")
 K @JSON@("OFFSET")
 Q
PUTDATA(JSON,DATA) ;
 S NODESIZE=201 ; TBD: lower (10) slows replies. But little advan over 1024, even slows the small.
 N LEN S LEN=$L(DATA)
 N NUM S NUM=LEN
 N OFFSET S OFFSET=@JSON@("OFFSET")
 N INDEX S INDEX=@JSON@("INDEX")
 I NUM+OFFSET-1>NODESIZE D
 . S NUM=NODESIZE-OFFSET+1
 . S @JSON@(@JSON@("INDEX"))=@JSON@(@JSON@("INDEX"))_$E(DATA,1,NUM)
 . S @JSON@("OFFSET")=1 S @JSON@("INDEX")=INDEX+1 S @JSON@(@JSON@("INDEX"))=""
 . D PUTDATA(JSON,$E(DATA,NUM+1,LEN))
 . Q
 E  D
 . S @JSON@(@JSON@("INDEX"))=@JSON@(@JSON@("INDEX"))_DATA
 . S @JSON@("OFFSET")=@JSON@("OFFSET")+NUM
 . Q
 Q
 ;
 ;
 ; Rules for JSON Values from www.json.org
 ; A JSON Value can be a string in double quotes, number, array, object (dictionary), 
 ; true|false|null.
 ;
 ; For string values
 ; 1. CTRL characters (0-31 except the escaped noted below) are not allowed as themselves.
 ; GT/M using UTF2HEX, Cache using ZHEX
 ; 2. Escape the following with a \
 ; - QUOTE 34 "
 ; - Backslash 92 \
 ; - BS 8 ^H Backspace, works on HP terminals/computers (b)
 ; - HT 9 ^I Horizontal tab, move to next tab stop (t)
 ; - LF 10 ^J Line Feed (n)
 ; - FF 12 ^L Form Feed, page eject (f) 
 ; - CR 13 ^M Carriage Return (r)
 ; 3. From 128->255+. Turn to \u0080 on. Note that "M" or "ASCII"
 ; is just to 255.
 ;
 ; Note: 
 ; - If character set is utf-8, then $L(($C(256))=1 (cheap check).
 ; - not escaping forward slash (47). JSON standard seems to say yes but few encoders
 ;   do this and all decoders accept it as is.
 ;
 ; NOTE: will get warning on GT/M as doesn't like conditional call to Cache's ZHEX.
 ;
JSONSTRING(IN) N ASCII,II,HEX,HH,OUT
 S ASCII(8)="\b"
 S ASCII(9)="\t"
 S ASCII(10)="\n"
 S ASCII(12)="\f"
 S ASCII(13)="\r"
 S ASCII(34)="\"""
 S ASCII(92)="\\"
 S OUT="" F II=1:1:$L(IN) D
 . S ASCII=$A(IN,II)
 . I $G(ASCII(ASCII))'="" S OUT=OUT_ASCII(ASCII) Q
 . I ASCII>31,ASCII<127 S OUT=OUT_$C(ASCII) Q
 . S HEX="" F HH=1:1:4 S HEX=$E("0123456789abcdef",ASCII#16+1)_HEX,ASCII=ASCII\16
 . S OUT=OUT_"\u"_HEX
 . Q
 Q OUT
 ;
]]></Routine>


<Routine name="FMQLQP" type="MAC" languagemode="0" timestamp="63266,3972.609066"><![CDATA[
FMQLQP ;CG/CD - Caregraf - FMQL Query Processor Entry Point; 11.25.2013  11:30
 ;;1.1b;FMQL;;Nov 25th, 2013
 ;
 ; FMQL Query Processor Entry Point
 ;
 ; FMQL Query Processor (c) Caregraf 2010-2013 AGPL
 ;
 ;
 ; Process Query
 ; support RPC or Web serializing friendly ^TMP holding JSON response 
 ; example: QUERY(.REPLY,"DESCRIBE 2-9") will describe the 9th entry in
 ; file 2 into ^TMP($J,"FMQLJSON")
 ; 
QUERY(QUERY) ;
 N PARAMS,PRSRES
 ; Note: storing in TMP for large JSON and older Cache-based systems
 K ^TMP($J,"FMQLJSON")  ; VistA Coding Convention
 ; Need to identify namespace of FM (VISTA or C***)
 K ^TMP($J,"NS") S ^TMP($J,"NS")=$S($P(^DIC(4.3,0),"^")="KERNEL SITE PARAMETERS":"C***",1:"VS")
 S PRSRES=$$PRSQUERY(QUERY,.PARAMS)
 I PRSRES'="" S ^TMP($J,"FMQLJSON",0)="{""error"":""Bad Query Form: "_PRSRES_"""}"
 E  D PROCQRY($NA(^TMP($J,"FMQLJSON")),.PARAMS)
 S REPLY=$NA(^TMP($J,"FMQLJSON"))
 Q REPLY
 ;
FMQLRPC(RPCREPLY,RPCARG) ;
 S RPCREPLY=$$QUERY(RPCARG)
 Q
 ; 
 ;
 ; PRSQUERY
 ; - invoke by S RESULT=$$PRSQUERY(INPUT,.PARAMS)
 ; ... returns a parse error when the INPUT is invalid, otherwise ""
 ;
 ; TODO: 
 ; - fully consume input and error if extraneous items
 ;
PRSQUERY(INPUT,PARAMS) ;
 N ERROR,QRYDEFS,OP,VAL,QUAL,TOKEN,ARGTYPE,NSTRT,NEND,NPOS,INPUTTV,CHECK
 S ERROR=""
 S QRYDEFS("SELECT","TYPE","LIMIT")="NUM"
 S QRYDEFS("SELECT","TYPE","OFFSET")="NUM"
 S QRYDEFS("SELECT","TYPE","AFTERIEN")="ID"
 S QRYDEFS("SELECT","TYPE","NOIDXMAX")="NUM"
 S QRYDEFS("SELECT","TYPE","IN")="QID"
 S QRYDEFS("SELECT","TYPE","ORDERBY")="FLDID"
 S QRYDEFS("SELECT","TYPE","FIELD")="FLDID"
 S QRYDEFS("COUNT","TYPE","LIMIT")="NUM"
 S QRYDEFS("COUNT","TYPE","OFFSET")="NUM"
 S QRYDEFS("COUNT","TYPE","AFTERIEN")="ID"
 S QRYDEFS("COUNT","TYPE","NOIDXMAX")="NUM"
 S QRYDEFS("COUNT","TYPE","IN")="QID"
 S QRYDEFS("COUNT REFS","QID")=""
 S QRYDEFS("DESCRIBE","QID","CSTOP")="NUM"
 S QRYDEFS("DESCRIBE","TYPE","LIMIT")="NUM"
 S QRYDEFS("DESCRIBE","TYPE","OFFSET")="NUM"
 S QRYDEFS("DESCRIBE","TYPE","AFTERIEN")="ID"
 S QRYDEFS("DESCRIBE","TYPE","CSTOP")="NUM"
 S QRYDEFS("DESCRIBE","TYPE","NOIDXMAX")="NUM"
 S QRYDEFS("DESCRIBE","TYPE","IN")="QID"
 S QRYDEFS("DESCRIBE","TYPE","ORDERBY")="FLDID"
 S QRYDEFS("SELECT TYPES","NONE","TOPONLY")=""
 S QRYDEFS("SELECT TYPES","NONE","POPONLY")=""
 S QRYDEFS("SELECT TYPE REFS","TYPE")=""
 S QRYDEFS("DESCRIBE BADTYPES","NONE")=""
 S QRYDEFS("DESCRIBE TYPE","TYPE","FULL")=""
 ; OP must be at start and can have spaces so loop to find
 D SKPWHITE(.INPUT)
 ; Go through all OPs each time - longest at end of list
 S OP="" F  S OP=$O(QRYDEFS(OP)) Q:OP=""  D
 . S VAL=$E(INPUT,1,$L(OP))
 . ; Either space is next or OP takes up whole input
 . Q:'($L(OP)=$L(INPUT)!($A(INPUT,$L(OP)+1)=32))
 . I VAL=OP S PARAMS("FOP")=OP S PARAMS("OP")=$$EXTTOINT(OP) Q
 I '$D(PARAMS("OP")) S ERROR="OP MISSING"
 Q:ERROR'="" ERROR
 S OP=PARAMS("FOP")
 D EATINP(.INPUT,OP)
 S QUAL="NONE"
 I '$D(QRYDEFS(OP,"NONE")) D
 . S VAL=$$PRSINP(.INPUT)
 . ; QID form ends in E to allow for non numeric 'meaningful' IENs
 . I $D(QRYDEFS(OP,"QID")),VAL?0.N0.1"_"1.N1"-"1.E S PARAMS("TYPE")=$P(VAL,"-",1) S QUAL="QID" S PARAMS("ID")=$P(VAL,"-",2) Q
 . I $D(QRYDEFS(OP,"TYPE")),VAL?0.N0.1"_"1.N S QUAL="TYPE" S PARAMS("TYPE")=VAL Q
 . S ERROR="TYPE MISSING"
 Q:ERROR'="" ERROR
 ; Take out FILTER text before looking at other arguments. It may contain those arguments as keywords. NOIDXMAX is a proxy for FILTER support.
 I $D(QRYDEFS(OP,QUAL,"NOIDXMAX")) D
 . S NSTRT=$F(INPUT,"FILTER")
 . Q:NSTRT=0  ; No Filter
 . S NEND=$F(INPUT,")",NSTRT)
 . S NPOS=NSTRT,NEND=0 F  S NPOS=$F(INPUT,")",NPOS) Q:'NPOS  S NEND=NPOS
 . I NEND=0 S ERROR="FILTER ) MISSING" Q
 . S VAL=$E(INPUT,NSTRT,NEND-1)
 . D SKPWHITE(.VAL)
 . I $E(VAL,1)'="(" S ERROR="FILTER ( MISSING" Q
 . S PARAMS("FILTER")=$E(VAL,2,$L(VAL)-1) ; less brackets
 . ; Redo INPUT to remove FILTER entirely
 . S INPUT=$E(INPUT,1,NSTRT-$L("FILTER")-1)_$E(INPUT,NEND,$L(INPUT))
 Q:ERROR'="" ERROR
 S TOKEN="" F  S TOKEN=$O(QRYDEFS(OP,QUAL,TOKEN)) Q:TOKEN=""!(ERROR'="")  D
 . S NSTRT=$F(INPUT,TOKEN)
 . Q:NSTRT=0  ; TOKEN not found
 . ; TOKEN only argument - by convention make value = 1
 . I QRYDEFS(OP,QUAL,TOKEN)="" S PARAMS(TOKEN)=1 Q
 . S INPUTTV=$E(INPUT,NSTRT,$L(INPUT))  ; There is an argument
 . S VAL=$$PRSINP(.INPUTTV," ",0)
 . ; QID allows E IENs; FLDID must be N or .N or N.N; ID 1.E ie/ not just float. May tighten
 . S ARGTYPE=QRYDEFS(OP,QUAL,TOKEN)
 . S CHECK=$S(ARGTYPE="NUM":VAL?1.N,ARGTYPE="QID":VAL?0.N0.1"_"1.N1"-"1.E,ARGTYPE="FLDID":VAL?0.N0.1"."1.N,ARGTYPE="ID":VAL?1.E,1:1)
 . I CHECK=0 S ERROR="INVALID VALUE FOR "_TOKEN_":"_VAL Q
 . S PARAMS($$EXTTOINT(TOKEN))=VAL
 Q:ERROR'="" ERROR
 ; REM: default of NOIDXMX and CSTOP set further inside
 Q ""
 ;
PROCQRY(REPLY,FMQLPARAMS) ;
 I '$D(FMQLPARAMS("OP")) S @REPLY@(0)="{""error"":""No Operation Specified""}" Q
 ; Schema
 I FMQLPARAMS("OP")="SELECT TYPES" D ALLTYPES^FMQLSCH(REPLY,.FMQLPARAMS) Q
 I FMQLPARAMS("OP")="DESCRIBE BADTYPES" D BADTYPES^FMQLSCH(REPLY,.FMQLPARAMS) Q
 I FMQLPARAMS("OP")="SELECT TYPE REFS" D ALLREFERRERSTOTYPE^FMQLSCH(.REPLY,.FMQLPARAMS) Q
 I FMQLPARAMS("OP")="DESCRIBE TYPE" D DESCRIBETYPE^FMQLSCH(REPLY,.FMQLPARAMS) Q
 ; Data
 I FMQLPARAMS("OP")="COUNT REFS" D CNTREFS^FMQLDATA(REPLY,.FMQLPARAMS) Q
 I ((FMQLPARAMS("OP")="DESCRIBE")&($D(FMQLPARAMS("ID")))) D DESONE^FMQLDATA(REPLY,.FMQLPARAMS) Q
 I ((FMQLPARAMS("OP")="SELECT")!(FMQLPARAMS("OP")="COUNT")!(FMQLPARAMS("OP")="DESCRIBE")) D ALL^FMQLDATA(REPLY,.FMQLPARAMS) Q
 S @REPLY@(0)="{""error"":""No Such Operation: "_FMQLPARAMS("OP")_"""}"
 Q
 ;
 ;
 ; TODO: internal code uses slightly different names for some parameters
 ;
EXTTOINT(EXTNAME) ;
 I EXTNAME="NOIDXMAX" Q "NOIDXMX"
 I EXTNAME="CSTOP" Q "CNODESTOP"
 Q EXTNAME
 ;
 ;
 ;
 ;
PRSINP(INPUT,SEP,EAT) ;
 N VAL
 S:'$D(SEP) SEP=" "
 S:'$D(EAT) EAT=1
 D SKPWHITE(.INPUT)
 S VAL=$P(INPUT,SEP,1)
 I EAT D EATINP(.INPUT,VAL)
 Q VAL
 ;
 ;
 ;
 ;
EATINP(INPUT,VAL) ;
 S INPUT=$E(INPUT,$L(VAL)+1,$L(INPUT))
 Q
 ;
 ;
 ;
 ;
SKPWHITE(INPUT) ;
 N IDX,NEXT,DONE
 S IDX=1
 S DONE=0 F  D  Q:DONE
 . S NEXT=$E(INPUT,IDX)
 . I NEXT="" S DONE=1 Q
 . I $A(NEXT)>32 S DONE=1 Q
 . S IDX=IDX+1
 Q:IDX=1
 S INPUT=$E(INPUT,IDX,$L(INPUT))
 Q
 ;
 ; TMP: move to utils (should be done outside). Removes HTTP escape.
 ;
UNESCSP(INPUT) ;
 N NEXT,DONE
 S DONE=0 F  D  Q:DONE
 . S NEXT=$F(INPUT,"%20")
 . I NEXT=0 S DONE=1 Q
 . S INPUT=$E(INPUT,1,NEXT-4)_" "_$E(INPUT,NEXT,$L(INPUT))
 Q
 ;
]]></Routine>


<Routine name="FMQLSCH" type="MAC" languagemode="0" timestamp="63272,6526.681772"><![CDATA[
FMQLSCH ;CG/CD - Caregraf - FMQL Schema Query Processor; 07/12/2013  11:30
 ;;1.1b;FMQLQP;;Nov 25th, 2013
 ;
 ; FMQL Schema Query Processor
 ;
 ; Companion of FMQLDATA - this resolves schema queries. Like its
 ; peer, it uses FLINF utilities rather than reading FM's raw dicts.
 ;
 ; FMQL Query Processor (c) Caregraf 2010-2013 AGPL
 ;
ALLTYPES(REPLY,FMQLPARAMS) ;
 N FILE,FILELABEL,TOPONLY,POPONLY,TCNT,CNT
 S TOPONLY=0,POPONLY=0,TCNT=0,CNT=0
 I $D(FMQLPARAMS("TOPONLY")),FMQLPARAMS("TOPONLY")="1" S TOPONLY=1
 I $D(FMQLPARAMS("POPONLY")),FMQLPARAMS("POPONLY")="1" S POPONLY=1
 D REPLYSTART^FMQLJSON(REPLY)
 S FILE=.109 ; allow .11 on but no .001 -> .1
 D LISTSTART^FMQLJSON(REPLY,"results")
 F  S FILE=$O(^DD(FILE)) Q:FILE'=+FILE  D
 . N FLINF D BLDFLINF^FMQLUTIL(FILE,.FLINF)  ; Important: initialize FLINF here
 . ; Will include WP which has ^DD entry but is not a file for FMQL
 . Q:$D(FLINF("BAD"))
 . S CNT=CNT+1
 . S:'$D(FLINF("PARENT")) TCNT=TCNT+1
 . I TOPONLY=1,$D(FLINF("PARENT")) Q
 . I POPONLY=1,'$D(FLINF("FMSIZE")) Q
 . D DICTSTART^FMQLJSON(REPLY)
 . D DASSERT^FMQLJSON(REPLY,"number",FILE)
 . D DASSERT^FMQLJSON(REPLY,"name",FLINF("LABEL"))
 . D:$D(FLINF("PARENT")) DASSERT^FMQLJSON(REPLY,"parent",FLINF("PARENT"))
 . D:$D(FLINF("GL")) DASSERT^FMQLJSON(REPLY,"global",FLINF("GL"))
 . D:$D(FLINF("FMSIZE")) DASSERT^FMQLJSON(REPLY,"count",FLINF("FMSIZE"))
 . D DICTEND^FMQLJSON(REPLY)
 . Q
 D LISTEND^FMQLJSON(REPLY)
 D DASSERT^FMQLJSON(REPLY,"allCount",CNT)
 D DASSERT^FMQLJSON(REPLY,"topCount",TCNT)
 ; Temporary (will move to a DESCRIBE SYSTEM. SITE and SITE LABEL
 D:$D(^DD("SITE")) DASSERT^FMQLJSON(REPLY,"siteLabel",^DD("SITE"))
 D:$D(^DD("SITE",1)) DASSERT^FMQLJSON(REPLY,"siteId",^DD("SITE",1))
 D DICTSTART^FMQLJSON(REPLY,"fmql")
 D DASSERT^FMQLJSON(REPLY,"OP","SELECT TYPES")
 I TOPONLY=1 D DASSERT^FMQLJSON(REPLY,"TOPONLY","true")
 I POPONLY=1 D DASSERT^FMQLJSON(REPLY,"POPONLY","true")
 D DICTEND^FMQLJSON(REPLY)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
BADTYPES(REPLY,FMQLPARAMS) ;
 N FILE,CNT,HASBFLD,FIELD
 S CNT=0
 D REPLYSTART^FMQLJSON(REPLY)
 S FILE=.109 ; allow .11 on but no .001 -> .1
 D LISTSTART^FMQLJSON(REPLY,"results")
 F  S FILE=$O(^DD(FILE)) Q:FILE'=+FILE  D
 . N FLINF D BLDFLINF^FMQLUTIL(FILE,.FLINF)  ; Important: initialize FLINF here
 . ; WP is a file (has DD entry) but not considered a file for FMQL
 . I $D(FLINF("BAD")),FLINF("BAD")="WP FILE" Q
 . I $D(FLINF("BAD")) D
 . . S CNT=CNT+1
 . . D DICTSTART^FMQLJSON(REPLY)
 . . D DASSERT^FMQLJSON(REPLY,"number",FILE)
 . . D DASSERT^FMQLJSON(REPLY,"corruption",FLINF("BAD"))
 . . D DICTEND^FMQLJSON(REPLY)
 . E  D
 . . S HASBFLD=0,FIELD=0 F  S FIELD=$O(^DD(FILE,FIELD)) Q:FIELD'=+FIELD  D
 . . . N FDINF D BLDFDINF^FMQLUTIL(.FLINF,FIELD,.FDINF)
 . . . I '$D(FDINF("BAD")) Q
 . . . I HASBFLD=0 D
 . . . . S HASBFLD=1
 . . . . S CNT=CNT+1
 . . . . D DICTSTART^FMQLJSON(REPLY)
 . . . . D DASSERT^FMQLJSON(REPLY,"number",FILE)
 . . . . D LISTSTART^FMQLJSON(REPLY,"badfields")
 . . . D DICTSTART^FMQLJSON(REPLY)
 . . . D DASSERT^FMQLJSON(REPLY,"number",FDINF("FIELD"))
 . . . D DASSERT^FMQLJSON(REPLY,"corruption",FDINF("BAD"))
 . . . D DICTEND^FMQLJSON(REPLY)
 . . I HASBFLD=1 D
 . . . D LISTEND^FMQLJSON(REPLY)
 . . . D DICTEND^FMQLJSON(REPLY)
 D LISTEND^FMQLJSON(REPLY)
 D DASSERT^FMQLJSON(REPLY,"badCount",CNT)
 D DICTSTART^FMQLJSON(REPLY,"fmql")
 D DASSERT^FMQLJSON(REPLY,"OP","DESCRIBE BADTYPES")
 D DICTEND^FMQLJSON(REPLY)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
ALLREFERRERSTOTYPE(REPLY,FMQLPARAMS) ;
 N FILE,FILELABEL,RFILE,RFILELABEL,RFIELD,RFIELDLABEL
 I '$D(FMQLPARAMS("TYPE")) D ERRORREPLY(REPLY,"No File Type") Q
 S FILE=$TR(FMQLPARAMS("TYPE"),"_",".")
 I '$D(^DIC(FILE,0,"GL")) D ERRORREPLY(REPLY,"Invalid Global File Type: "_FILE) Q  ; top level only
 D REPLYSTART^FMQLJSON(REPLY)
 S FILELABEL=$O(^DD(FILE,0,"NM",""))
 D DASSERT^FMQLJSON(REPLY,"fmqlFileName",FILELABEL) ; always file name back
 D LISTSTART^FMQLJSON(REPLY,"results")
 S RFILE="" F  S RFILE=$O(^DD(FILE,0,"PT",RFILE)) Q:RFILE'=+RFILE  D  ; Order ala IEN Order
 . Q:'$D(^DIC(RFILE,0,"GL"))  ; TBD: only do globals for now
 . Q:'$D(^DD(RFILE,0,"NM"))  ; rfile must be named
 . D DICTSTART^FMQLJSON(REPLY)
 . S RFILELABEL=$O(^DD(RFILE,0,"NM",""))
 . D DASSERT^FMQLJSON(REPLY,"rfile",RFILE)
 . D DASSERT^FMQLJSON(REPLY,"rfileLabel",RFILELABEL)
 . D LISTSTART^FMQLJSON(REPLY,"rfields")
 . S RFIELD="" F  S RFIELD=$O(^DD(FILE,0,"PT",RFILE,RFIELD)) Q:RFIELD'=+RFIELD  D
 . . Q:'$D(^DD(RFILE,RFIELD,0))  ; Skip Corruption
 . . D DICTSTART^FMQLJSON(REPLY)
 . . S RFIELDLABEL=$P(^DD(RFILE,RFIELD,0),"^") ; TBD quit if no label
 . . D DASSERT^FMQLJSON(REPLY,"rfield",RFIELD)
 . . D DASSERT^FMQLJSON(REPLY,"rfieldLabel",RFIELDLABEL)
 . . D DICTEND^FMQLJSON(REPLY)
 . . Q
 . D LISTEND^FMQLJSON(REPLY)
 . D DICTEND^FMQLJSON(REPLY)
 . Q
 D LISTEND^FMQLJSON(REPLY)
 D DICTSTART^FMQLJSON(REPLY,"fmql")
 D DASSERT^FMQLJSON(REPLY,"OP","SELECT TYPE REFS")
 D DASSERT^FMQLJSON(REPLY,"TYPE",$TR(FILE,".","_"))
 D DASSERT^FMQLJSON(REPLY,"TYPELABEL",FILELABEL)
 D DICTEND^FMQLJSON(REPLY)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
ERRORREPLY(REPLY,MSG) ;
 D REPLYSTART^FMQLJSON(REPLY)
 D DASSERT^FMQLJSON(REPLY,"error",MSG)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
DESCRIBETYPE(REPLY,FMQLPARAMS) ;
 I '$D(FMQLPARAMS("TYPE")) D ERRORREPLY(REPLY,"No File Type") Q
 N FILE S FILE=$TR(FMQLPARAMS("TYPE"),"_",".")
 N FLINF D BLDFLINF^FMQLUTIL(FILE,.FLINF)
 ; Note: corrupt file leads to an error with src of corruption
 I $D(FLINF("BAD")) D ERRORREPLY(REPLY,"Corrupt or Invalid File Type: "_FLINF("BAD")) Q
 I $D(FLINF("PARENT")) D SUBFILEINFO(REPLY,.FLINF) Q
 D TOPFILEINFO(REPLY,.FLINF)
 Q
 ;
TOPFILEINFO(REPLY,FLINF) ;
 D REPLYSTART^FMQLJSON(REPLY)
 D DASSERT^FMQLJSON(REPLY,"name",FLINF("LABEL"))
 D DASSERT^FMQLJSON(REPLY,"number",FLINF("FILE"))
 D DASSERT^FMQLJSON(REPLY,"location",FLINF("GL"))
 D:$D(FLINF("FMSIZE")) DASSERT^FMQLJSON(REPLY,"count",FLINF("FMSIZE"))
 D:$D(FLINF("LSTIEN")) DASSERT^FMQLJSON(REPLY,"lastIEN",FLINF("LSTIEN"))
 ; Leaving Descr outside FLINF as used so often.
 I $D(^DIC(FILE,"%D",0))  D  ; DESCRIPTION
 . D WPASTART^FMQLJSON(REPLY,"DESCRIPTION","-1")
 . S I=0 F  S I=$O(^DIC(FILE,"%D",I)) Q:I'=+I  D
 . . D WPALINE^FMQLJSON(REPLY,^DIC(FILE,"%D",I,0))
 . . Q
 . D WPAEND^FMQLJSON(REPLY)
 . Q
 D:$D(FLINF("APPGRPS")) DASSERT^FMQLJSON(REPLY,"applicationGroups",FLINF("APPGRPS"))
 D:$D(FLINF("VERSION")) DASSERT^FMQLJSON(REPLY,"version",FLINF("VERSION"))
 D:$D(FLINF("VPACKAGE")) DASSERT^FMQLJSON(REPLY,"vpackage",FLINF("VPACKAGE"))
 D FIELDSINFO(.FLINF)
 D DICTSTART^FMQLJSON(REPLY,"fmql")
 D DASSERT^FMQLJSON(REPLY,"OP","DESCRIBE TYPE")
 D DASSERT^FMQLJSON(REPLY,"TYPE",FLINF("EFILE"))
 D DASSERT^FMQLJSON(REPLY,"TYPELABEL",FLINF("LABEL"))
 D DICTEND^FMQLJSON(REPLY)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
SUBFILEINFO(REPLY,FLINF) ;
 D REPLYSTART^FMQLJSON(REPLY)
 D DASSERT^FMQLJSON(REPLY,"name",FLINF("LABEL"))
 D DASSERT^FMQLJSON(REPLY,"number",FLINF("FILE"))
 D DASSERT^FMQLJSON(REPLY,"parent",FLINF("PARENT"))
 ; TBD: Search CFILE for field that contains this one. Get field and description.
 D FIELDSINFO(.FLINF)
 D DICTSTART^FMQLJSON(REPLY,"fmql")
 D DASSERT^FMQLJSON(REPLY,"OP","DESCRIBE TYPE")
 D DASSERT^FMQLJSON(REPLY,"TYPE",FLINF("EFILE"))
 D DASSERT^FMQLJSON(REPLY,"TYPELABEL",FLINF("LABEL"))
 D DICTEND^FMQLJSON(REPLY)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
FIELDSINFO(FLINF) ;
 N FILE S FILE=FLINF("FILE")
 D LISTSTART^FMQLJSON(REPLY,"fields")
 S FIELD=0 F  S FIELD=$O(^DD(FILE,FIELD)) Q:FIELD'=+FIELD  D
 . N FDINF D BLDFDINF^FMQLUTIL(.FLINF,FIELD,.FDINF)
 . Q:$D(FDINF("BAD"))
 . D DICTSTART^FMQLJSON(REPLY)
 . D DASSERT^FMQLJSON(REPLY,"number",FDINF("FIELD"))
 . ; Send over all the flags. May process more on client side
 . D DASSERT^FMQLJSON(REPLY,"flags",FDINF("FLAGS"))
 . D DASSERT^FMQLJSON(REPLY,"name",FDINF("LABEL"))
 . D DASSERT^FMQLJSON(REPLY,"pred",FDINF("PRED"))
 . D:$D(FDINF("LOC")) DASSERT^FMQLJSON(REPLY,"location",FDINF("LOC"))
 . ; For now, only note simple indexes. Not all ^DD(FILE,"IX",FIELD) as MUMPS there too
 . D:$D(FDINF("IDX")) DASSERT^FMQLJSON(REPLY,"index",FDINF("IDX"))
 . D:$D(FDINF("TRIGS")) DASSERT^FMQLJSON(REPLY,"triggers",FDINF("TRIGS"))
 . D:$D(FDINF("CREFNO")) DASSERT^FMQLJSON(REPLY,"crossReferenceCount",FDINF("CREFNO"))
 . D DASSERT^FMQLJSON(REPLY,"type",FDINF("TYPE"))
 . ; Extra details not in FDINF (yet)
 . N FLDDETAILS
 . I FDINF("TYPE")=9 S FLDDETAILS=+FDINF("FLAGS") ; Multiple
 . ; For now, pass back original values even for boolean
 . I ((FDINF("TYPE")=3)!(FDINF("TYPE")=12)) S FLDDETAILS=$P(^DD(FILE,FIELD,0),"^",3) ; Set
 . I FDINF("TYPE")=7 S FLDDETAILS=+$P(FDINF("FLAGS"),"P",2) ; Pointer
 . I FDINF("TYPE")=11,FDINF("FLAGS")["P" S FLDDETAILS=+$P(FDINF("FLAGS"),"P",2) ; Pointer (IEN pts)
 . ; TBD: Final FMQL won't distinguish vptr from ptr. MUMPS-side thing.
 . I FDINF("TYPE")=8 D
 . . S FLDDETAILS=$$VARPOINTERRANGE(FILE,FIELD) ; V Pointer
 . D:$D(FLDDETAILS) DASSERT^FMQLJSON(REPLY,"details",FLDDETAILS)
 . ; TODO: move into FDINF as useful for filters
 . I $L($P(^DD(FILE,FIELD,0),"^",5)) D
 . . ; TODO: calculate better - using length to get over all internal ^
 . . N CALC S CALC=$P(^DD(FILE,FIELD,0),"^",5,$L(^DD(FILE,FIELD,0)))
 . . Q:CALC="Q"
 . . N CALCTYPE S CALCTYPE=$S(FDINF("TYPE")=6:"computation",1:"inputTransform")
 . . D DASSERT^FMQLJSON(REPLY,CALCTYPE,CALC)
 . D:$D(FDINF("HIDE")) DASSERT^FMQLJSON(REPLY,"hidden","true")
 . ; Keeping WP here. Not useful for checking and could be big.
 . I $D(^DD(FILE,FIELD,21,1))  D
 . . D WPASTART^FMQLJSON(REPLY,"DESCRIPTION","-1")
 . . N I S I=0 F  S I=$O(^DD(FILE,FIELD,21,I)) Q:I'=+I  D
 . . . D WPALINE^FMQLJSON(REPLY,^DD(FILE,FIELD,21,I,0))
 . . . Q
 . . D WPAEND^FMQLJSON(REPLY)
 . D DICTEND^FMQLJSON(REPLY)
 D LISTEND^FMQLJSON(REPLY)
 Q
 ;
 ; TODO: use FMQLUTIL's instead (PLOC reassemble)
VARPOINTERRANGE(FILE,FIELD) ;
 N X,VPS,VP
 S VPS=""
 I '$D(^DD(FILE,FIELD,"V")) Q VPS ; TBD ERROR
 S X=0 F  S X=$O(^DD(FILE,FIELD,"V",X)) Q:X'=+X  D
 . S VP=$P(^DD(FILE,FIELD,"V",X,0),"^",1)
 . I VPS'="" S VPS=VPS_";"
 . S VPS=VPS_VP
 Q VPS
 ;
]]></Routine>


<Routine name="FMQLSLAB" type="MAC" languagemode="0" timestamp="63152,35930.627635"><![CDATA[
FMQLSLAB ;CG/CD - Caregraf - FMQL Schema Enhancement for Lab; 07/12/2013  11:30
 ;;1.0;FMQLQP;;Jul 12th, 2013
 ;
 ;
 ;
 ; FMQL Schema Enhancement for Lab (SLAB). 
 ; - peer of SSAM (SAMEAS)
 ;
 ; FMQL Query Processor (c) Caregraf 2010-2013 AGPL
 ; 
 ; Exposes hidden Lab (CH) variables to a blank node pending a set of 
 ; cross references that does this work in an enhanced lab schema. This makes
 ; CH labs look like Radiology and Pharmacy.
 ;
 ; This does similar calculations to (lot's of redundancy in lab):
 ; - HL7 lab: subroutines called from CH^LA7OBX1 from GCPR^LA7QRY
 ; - Lab query routines: TSTRES^LRRPU called from CH^LR7OR2
 ; - Other: CHNODE^LRPXAPI2.m
 ; 
 ; CH data is stored in a proprietary format in FileMan's location for a lab
 ; value. Example ...
 ;   "7.19^^81323.0000!!!4378!!!1^6877^70!4.8!10.8!2!50!!x10 3/uL!1!3^^^^1"
 ; The structure of such values is explained in the code below.
 ;
 ; Note: unlike the VA routines, the code below DOES NOT account for older versions
 ; of the lab package which failed to fill in certain values.
 ;
 ; Issue of inconsistent settings in 60:
 ; VistA seems to allow meaningless definitions in file 60 ...
 ; - numerics with no units? (ex/ GWB, 60-1100, 60-5173)
 ; - references for free texts (ex/ GWB, 60-6135, 60-5826)
 ; - set values with a mix of numeric and text and still get ref ranges and units
 ;   (ex/ GWB, 60-151)
 ; - numeric but interpretation is an explanation (60-5865)
 ; - ... TBD: check type in 60 AND ONLY send ranges, units if numeric.
 ; For now, this extractor DOES not remove such inconsistencies. Must choose the 
 ; right balance between a consistent schema and exposing what the system has.
 ;
 ; TBD:
 ; - panel to lab order. Work correlation - logic in LR7OR1. Custom indexes
 ;   in 68 and 69 to go from a "lab order id" to file 100 id. Not like pharma
 ;   - the id is not called out explicitly in a field
 ; - value of "see comment"
 ; - TYPE: SET vs NUMERIC vs STRING from 60
 ;   - LA7VOBX1: $S("canccomment"[$P(LA7VAL,"^"):1,1:0)
 ;   - OBX2^LA7VOBXA: TYPE
 ; - Partial or Final
 ;   S LA7X=$S("canccommentpending"[$P(LA7VAL,"^"):$P(LA7VAL,"^"),1:"F")
 ;   I LA7RS="C" S LA7X=LA7RS
 ;   S LA7OBX(11)=$$OBX11^LA7VOBX(LA7X)
 ; - Problem of "Free Text" 60 with a unit. ie. if non numeric nix unit
 ; - Critical vs Reference: HL7 V3 HH (High Alert) vs H (High)? Or just expose
 ;   critical and leave interpretation to the client?
 ;
 ;
BLDBNODES(FAR6304,FID) N BID,FLOC,ID,VAL
 S ID=$P(FID,"_")
 S BID=1
 D BNLISTSTART^FMQLJSON(REPLY,"9999999999_6304","CHVALS","9999999999")
 S FLOC=1 F  S FLOC=$O(@FAR6304@(ID,FLOC)) Q:FLOC'=+FLOC  D
 . S VAL=@FAR@(ID,FLOC)
 . D BLDBNODE(FLOC,VAL,BID_"_"_FID)
 . S BID=BID+1
 D BNLISTEND^FMQLJSON(REPLY)
 Q
 ;
BLDBNODE(FLOC,VAL,FID) ;
 ; Start with 60 reference. Must have it or quit.
 N LC S LC=$P(VAL,"^",3)  ; Codes
 Q:LC=""
 N LC60 S LC60=$P(LC,"!",7)  ; 60 ref is in 7th position of code section
 Q:LC60=""
 Q:'$D(^LAB(60,LC60))
 N LABEL60 S LABEL60="LABORATORY TEST/"_$P(^LAB(60,LC60,0),"^")
 ;
 N LVAL S LVAL=$P(VAL,"^")  ; Get Value. TBD: need to check if there is one?
 ;
 ; TBD: FILTER (two values to pick)
 ; Check if test is OK to send - (O)utput or (B)oth
 ; S LA7X=$P(VAL,"^",12)
 ; I LA7X]"","BO"'[LA7X Q
 ; I LA7X="",'$$OKTOSND^LA7VHLU1(LRSS,LRSB,+$P($P(LA7VAL,"^",3),"!",7)) Q
 ;
 D DICTSTART^FMQLJSON(REPLY)
 ;
 ; TMP: giving self 9999999999 as context for FMQL files/subfiles
 D ASSERT^FMQLJSON(REPLY,"URI",".01","7","9999999999_6304-"_$TR(FID,".","_"),"CHBNODE-"_LABEL60)
 ;
 ; Codes (TBD: don't take 64/LOINC. Take from 60->64->95.3)
 ; Result 64. Default to Order 64 (or ""). Nix NaN WKLD code
 ; S:$P(LC,"!")="81323.0000" $P(LC,"!")=""
 ; S:$P(LC,"!",2)="81323.0000" $P(LC,"!",2)=""
 ; N LC64 S LC64=$S($P(LC,"!",2)'="":$P(LC,"!",2),1:$P(LC,"!"))
 ; 0.1 IEN of 60
 ; N SAMEAS60 ; LOINC (95.3) or NLT (64) if available
 ; I $P(LC,"!",3)'="" S SAMEAS60("URI")="95_3-"_$P(LC,"!",3) S SAMEAS60("LABEL")="DUMMYLOINC"
 ; E  I LC64'="" S SAMEAS60("URI")="64-"_LC64 S SAMEAS60("LABEL")="DUMMY64"
 N SAMEAS60
 D RESVS60^FMQLSSAM(LC60,.SAMEAS60)
 D ASSERT^FMQLJSON(REPLY,"TEST",".01","7","60-"_LC60,LABEL60,.SAMEAS60)
 ;
 ; 0.2: Value (complication of "see comment" and type)
 D ASSERT^FMQLJSON(REPLY,"VALUE",".02","4",LVAL)
 ;
 ; 0.11: Method or Site - TBD redo per OBX17^LA7VOBX
 ; Note: Mayo appears here in MMH as one of three options. Goes to WKLD suffix.
 I $P(LC,"!",4) D
 . Q:'$D(^LAB(64.2,$P(LC,"!",4)))
 . N LABEL S LABEL="WKLD SUFFIX CODES/"_$P(^LAB(64.2,$P(LC,"!",4),0),"^")
 . D ASSERT^FMQLJSON(REPLY,"METHOD",".11","7","64_2-"_$P(LC,"!",4),LABEL)
 ;
 ; 0.4: Verify Person
 I $P(VAL,"^",4) D
 . Q:'$D(^DPT($P(VAL,"^",4)))
 . N LABEL S LABEL="NEW PERSON/"_$P(^DPT($P(VAL,"^",4),0),"^")
 . D ASSERT^FMQLJSON(REPLY,"VERIFY PERSON",".04","7","200-"_$P(VAL,"^",4),LABEL)
 ;
 ; Reference Ranges and Unit (Configured in 60.01 Specimen)
 ; take from value as 60.01 may have changed since interpretation
 ; TBD: consider interpretation as coded value for ease of mapping to obsi/H, obsi/L
 N LRU S LRU=$P(VAL,"^",5)  ; Reference Ranges and Unit
 D:$P(LRU,"!",7)'="" ASSERT^FMQLJSON(REPLY,"UNITS",".07","4",$P(LRU,"!",7))
 ; .08: Specimen (61). Also in $P(0,"^",5)
 I $P(LRU,"!") D
 . Q:'$D(^LAB(61,$P(LRU,"!")))
 . N LABEL S LABEL="TOPOGRAPHY FIELD/"_$P(^LAB(61,$P(LRU,"!"),0),"^")
 . D ASSERT^FMQLJSON(REPLY,"SPECIMEN",".08","7","61-"_$P(LRU,"!"),LABEL)
 ; .09,.10: Range - high and low
 ; Ignore criticals (4/5). Use reference. If none, use therapeutic.
 N LRLOW S LRLOW=$S($P(LRU,"!",2)'="":$P(LRU,"!",2),1:$P(LRU,"!",11))
 D:LRLOW'="" ASSERT^FMQLJSON(REPLY,"RANGE LOW",".09","4",LRLOW)
 N LRHIGH S LRHIGH=$S($P(LRU,"!",3)'="":$P(LRU,"!",3),1:$P(LRU,"!",12))
 D:LRHIGH'="" ASSERT^FMQLJSON(REPLY,"RANGE HIGH",".10","4",LRHIGH)
 ;
 ; 0.3: Interpretation (not there for NORMAL or no reference ranges)
 D:$P(VAL,"^",2)'="" ASSERT^FMQLJSON(REPLY,"INTERPRETATION",".03","4",$P(VAL,"^",2))
 ;
 D DICTEND^FMQLJSON(REPLY)
 ;
 Q
 ;
]]></Routine>


<Routine name="FMQLSSAM" type="MAC" languagemode="0" timestamp="63221,12602.226215"><![CDATA[
FMQLSSAM ;CG/CD - Caregraf - FMQL Schema Enhancement for Terminologies; 07/12/2013  11:30
 ;;1.0;FMQLQP;;Jul 12th, 2013
 ;
 ;
 ; FMQL Schema Enhancement for Terminologies - sameas relationships
 ;
 ; FMQL Query Processor (c) Caregraf 2010-2013 AGPL
 ;
 ; Link (declare sameas) local vocabulary/resources to standard or national 
 ; equivalents. This is part of FMQL's FileMan schema enhancements and 
 ; all vocabs identified in the vocabulary graph should be processed here.
 ;
 ; Get SAMEAS of: LOCAL (no national map where there might be), LOCAL:XX-XX
 ; a local only map, VA:xxxx (usually VUIDs), NLT64 (for Lab only)
 ;
 ; Note: Like other enhancements, the logic could be migrated to FileMan's 
 ; schema. Computed pointers called "sameas" could be added to relevant files.
 ;
 ; TODO: 
 ; - VA: NDC (11 form)
 ; - DEFLABEL passed in for VUID. Lookup explicitly with better .01 routine
 ;
 ; IMPORTANT: pass in empty SAMEAS
 ;
RESOLVE(FILENUM,IEN,DEFLABEL,SAMEAS) ;
 Q:'$D(^DIC(FILENUM,0,"GL"))  ; catches CNode
 Q:IEN'=+IEN  ; catch non numeric IEN
 ; Could just check $D(^PSDFDB)
 I ^TMP($J,"NS")="VS" D RESVS(FILENUM,IEN,DEFLABEL,.SAMEAS) Q
 D RESC(FILENUM,IEN,DEFLABEL,.SAMEAS)  ; C*** Vocabs
 Q
 ;
 ;
 ; VS Resolution
 ;
RESVS(FILENUM,IEN,DEFLABEL,SAMEAS) ;
 I FILENUM="50.7" D RESVS50dot7(IEN,.SAMEAS) Q  ; PHARMACY ORDERABLE
 I FILENUM="50" D RESVS50(IEN,.SAMEAS) Q  ; DRUG
 I FILENUM="71" D RESVS71(IEN,.SAMEAS) Q  ; RAD/NUC PROCEDURE
 I FILENUM="790.2" D RESVS790dot2(IEN,.SAMEAS) Q  ; WV PROCEDURE
 I FILENUM="757" D RESVS757(IEN,.SAMEAS) Q  ; Major Concept
 I FILENUM="757.01" D RESVS757dot01(IEN,.SAMEAS) Q  ; EXP
 I FILENUM="9999999.27" D RESVS9999999dot27(IEN,.SAMEAS) Q  ; Prov Nav
 I FILENUM="60" D RESVS60(IEN,.SAMEAS) Q  ; Lab Local
 I FILENUM="64" D RESVS64(IEN,.SAMEAS) Q  ; Lab National WKLD
 I FILENUM="200" D RESVS200(IEN,.SAMEAS) Q  ; NPI for Providers
 D RESVSVAFIXED(FILENUM,IEN,DEFLABEL,.SAMEAS) Q:$D(SAMEAS("URI"))
 D RESVSSTANDARD(FILENUM,IEN,DEFLABEL,.SAMEAS) Q:$D(SAMEAS("URI"))
 D RESVSVUID(FILENUM,IEN,DEFLABEL,.SAMEAS) Q:$D(SAMEAS("URI"))
 Q
 ;
 ;
 ; If VUID-ed file entry has no VUID then will return "LOCAL" as sameAs value 
 ;
 ; TBD: VUIDs for many coded-value fields, all given in 8985_1. Can LU with NS
 ;      CR _11-537. Ex/ YES/NO fields etc. File#,Field#,IVALUE leads to VUID
 ;      Note: complication of 63_04. Could local enum labs get VUIDs too?
RESVSVUID(FILENUM,IEN,DEFLABEL,SAMEAS) ;
 N VUID,VUIDE
 I (($G(DEFLABEL)="")!($G(IEN)="")) Q  ; RESVSDRUG, maybe more need this
 Q:'$D(^DD(FILENUM,"B","VUID",99.99))
 S SAMEAS("URI")="LOCAL"
 S VUIDE=^DIC(FILENUM,0,"GL")_IEN_","_"""VUID"""_")"
 I DEFLABEL["/" S DEFLABEL=$TR(DEFLABEL,"/","-")  ; TMP: names with /. TBD fix.
 I $G(@VUIDE) S SAMEAS("URI")="VA:"_$P($G(@VUIDE),"^",1) S SAMEAS("LABEL")=DEFLABEL  Q
 Q
 ;
 ; Fixed files: 5,11,13 no VUID but VA standard
 ; Note: 10(.1/.2) not in here. CDC/HL7 coded.
 ; Unlike VUIDes will make SAMEAS take same value as IEN.
RESVSVAFIXED(FILENUM,IEN,DEFLABEL,SAMEAS) ;
 I FILENUM="5"!(FILENUM="11")!(FILENUM="13")  D
 . S SAMEAS("URI")="VA:"_$TR(FILENUM,".","_")_"-"_IEN
 . S SAMEAS("LABEL")=$P(DEFLABEL,"/",2)
 Q 
 ;
 ; Standard files: 80 (ICD), 81 (CPT), 8932.1 (Provider Codes)
 ; TBD: 95.3 (LOINC), SNOMED/RT 61 ...
 ; ISSUE: must intercept LOINC BEFORE try VUID sameas
 ; These should never be local - unless in error
RESVSSTANDARD(FILENUM,IEN,DEFLABEL,SAMEAS) ;
 ; No default local: should all have codes!
 I FILENUM="80" D
 . Q:'$D(@("^ICD9("_IEN_",0)"))  ; TBD: log invalid
 . S SAMEAS("URI")="ICD9CM:"_$P(DEFLABEL,"/",2)
 . S SAMEAS("LABEL")=$P(@("^ICD9("_IEN_",0)"),"^",3)
 I FILENUM="81" D
 . Q:'$D(@("^ICPT("_IEN_",0)"))
 . S SAMEAS("URI")="CPT:"_$P(DEFLABEL,"/",2)
 . S SAMEAS("LABEL")=$P(@("^ICPT("_IEN_",0)"),"^",2)
 I FILENUM="8932.1" D 
 . Q:'$D(^USC(8932.1,IEN,0))
 . S SAMEAS("URI")="LOCAL" ; inactives lack codes
 . N X12CODE S X12CODE=$P(^USC(8932.1,IEN,0),"^",7)
 . Q:X12CODE=""
 . S SAMEAS("URI")="HPTC:"_X12CODE
 . S SAMEAS("LABEL")=$P(^USC(8932.1,IEN,0),"^",2)
 ; For 61: SNOMED RT, snomed code and name
 Q
 ;
 ; Provider Narrative is used in problems (and POV, V CPT) to describe
 ; a problem. Most but not all resolve to expressions which in turn resolve
 ; to meaningful ICD codes.
RESVS9999999dot27(IEN,SAMEAS) ;
 S:'$D(SAMEAS("URI")) SAMEAS("URI")="LOCAL"
 Q:'$D(^AUTNPOV(IEN,757))
 N SEVEN5701 S SEVEN5701=$P(^AUTNPOV(IEN,757),"^")
 Q:SEVEN5701=""
 D RESVS757dot01(SEVEN5701,.SAMEAS)
 Q  ; don't fall back on a 757.01 that doesn't resolve to 757
 ;
 ; Lexicon expressions: turn expression (757_01) into major concept (757)
RESVS757dot01(IEN,SAMEAS) ;
 S:'$D(SAMEAS("URI")) SAMEAS("URI")="LOCAL"
 Q:'$D(^LEX(757.01,IEN,1))
 N SEVEN57 S SEVEN57=$P(^LEX(757.01,IEN,1),"^")
 Q:SEVEN57=""
 D RESVS757(SEVEN57,.SAMEAS)
 Q
 ;
RESVS757(IEN,SAMEAS) ;
 Q:'$D(^LEX(757,IEN,0))
 ; Even major concept has a major expression and its label comes from that
 N MJRE S MJRE=$P(^LEX(757,IEN,0),"^")
 Q:MJRE=""
 Q:'$D(^LEX(757.01,MJRE,0))
 N SAMEASLABEL S SAMEASLABEL=$P(^LEX(757.01,MJRE,0),"^")
 Q:SAMEASLABEL=""
 S SAMEAS("URI")="VA:757-"_IEN
 S SAMEAS("LABEL")=SAMEASLABEL
 Q
 ;
 ; Pharmacy Orderable Item facade for 50.
 ; Three cases: no link to 50, link to 50 but it doesn't link and 50 links.
 ; the second case leads to a qualified local ala "LOCAL:50-IEN"
RESVS50dot7(IEN,SAMEAS) ;
 S:'$D(SAMEAS("URI")) SAMEAS("URI")="LOCAL"
 Q:'$D(^PSDRUG("ASP",IEN))
 N DRUGIEN S DRUGIEN=$O(^PSDRUG("ASP",IEN,""))
 D RESVS50(DRUGIEN,.SAMEAS)
 Q:SAMEAS("URI")'="LOCAL"
 N SAMEASLABEL S SAMEASLABEL=$P(^PSDRUG(DRUGIEN,0),"^")
 Q:SAMEASLABEL=""
 S SAMEAS("URI")="LOCAL:50-"_DRUGIEN
 S SAMEAS("LABEL")=SAMEASLABEL
 Q
 ;
 ; VistA Drug 50 to Standard 50.68 or mark as local
RESVS50(IEN,SAMEAS) ;
 S:'$D(SAMEAS("URI")) SAMEAS("URI")="LOCAL"
 Q:'$D(^PSDRUG(IEN,"ND"))  ; Not mandatory to map to VA Product
 N VAPIEN S VAPIEN=$P(^PSDRUG(IEN,"ND"),"^",3)
 ; Q:VAPIEN'=+VAPIEN ; catch corrupt IEN
 Q:VAPIEN'=+VAPIEN  ; VAPIEN may be zero so can't be subscript
 D RESVSVUID("50.68",VAPIEN,$P(^PSDRUG(IEN,"ND"),"^",2),.SAMEAS)
 Q
 ;
 ;
 ; TBD: RESVS50_605 (DRUG CLASS). VA GETS hard codes a name map for this.
 ;
 ; TBD: one CPT resolver. Switch on 71, 790_2 and more. Merge the following
 ;
 ; Special: VistA Rad/Nuc Procedures 71 to Standard CPT
RESVS71(IEN,SAMEAS) ;
 S:'$D(SAMEAS("URI")) SAMEAS("URI")="LOCAL"
 Q:'$D(^DIC(71,0,"GL"))
 N CODEAR S CODEAR=^DIC(71,0,"GL")
 D RESVSTOCPT(IEN,CODEAR,9,.SAMEAS)
 Q
 ;
 ; Special: VistA WV Procedures 790_2 to Standard CPT
RESVS790dot2(IEN,SAMEAS) ;
 S:'$D(SAMEAS("URI")) SAMEAS("URI")="LOCAL"
 Q:'$D(^DIC(790.2,0,"GL"))
 N CODEAR S CODEAR=^DIC(790.2,0,"GL")
 D RESVSTOCPT(IEN,CODEAR,8,.SAMEAS)
 Q
 ;
 ; Reusable CPT sameas formatter
RESVSTOCPT(IEN,CODEAR,CPTFI,SAMEAS) ;
 S:'$D(SAMEAS("URI")) SAMEAS("URI")="LOCAL"
 Q:'$D(@(CODEAR_IEN_",0)"))
 N CPT S CPT=$P(@(CODEAR_IEN_",0)"),"^",CPTFI)
 Q:CPT=""
 Q:'$D(^ICPT("B",CPT))
 S CPTIEN=$O(^ICPT("B",CPT,""))
 N SAMEASLABEL S SAMEASLABEL=$P(^ICPT(CPTIEN,0),"^",2)
 Q:SAMEASLABEL=""
 S SAMEAS("URI")="CPT:"_CPT
 S SAMEAS("LABEL")=SAMEASLABEL
 Q
 ;
 ; TBD: LU LRVER1
RESVS60(IEN,SAMEAS) ;
 S:'$D(SAMEAS("URI")) SAMEAS("URI")="LOCAL"
 Q:'$D(^LAB(60,IEN,64))
 ; Take Result NLT over National NLT
 N NLTIEN S NLTIEN=$S($P(^LAB(60,IEN,64),"^",2):$P(^LAB(60,IEN,64),"^",2),$P(^LAB(60,IEN,64),"^"):$P(^LAB(60,IEN,64),"^"),1:"")
 Q:NLTIEN=""
 Q:'$D(^LAM(NLTIEN))
 D RESVS64(NLTIEN,.SAMEAS)
 Q
 ;
 ; By design, do not map from WKLD to LOINC to its VUID. 
 ; VA assigned VUIDs to LOINCs but want LOINC and not VUID in sameas.
 ; TBD: LU LRVER1. See its logic.
RESVS64(IEN,SAMEAS) ;
 S:'$D(SAMEAS("URI")) SAMEAS("URI")="LOCAL"
 N WKLDCODE S WKLDCODE=$P(^LAM(IEN,0),"^",2)
 Q:'WKLDCODE?5N1".0000"  ; leave local codes
 S SAMEAS("URI")="VA:wkld"_$P(WKLDCODE,".",1) ; 00000 dropped
 S SAMEAS("LABEL")=$P(^LAM(IEN,0),"^")
 Q:'$D(^LAM(IEN,9))
 N DEFLN S DEFLN=$P(^LAM(IEN,9),"^")
 Q:DEFLN=""
 Q:'$D(^LAB(95.3,DEFLN))
 Q:'$D(^LAB(95.3,DEFLN,81))  ; shortname
 S SAMEAS("URI")="LOINC:"_$P(^LAB(95.3,DEFLN,0),"^")_"-"_$P(^LAB(95.3,DEFLN,0),"^",15)  ; code and check_digit
 S SAMEAS("LABEL")=^LAB(95.3,DEFLN,81)
 Q
 ;
 ; Providers have NPIs
 ;
RESVS200(IEN,SAMEAS) ;
 S:'$D(SAMEAS("URI")) SAMEAS("URI")="LOCAL"
 Q:'$D(^VA(200,IEN,"NPI"))
 N NPI S NPI=$P(^VA(200,IEN,"NPI"),"^")
 Q:NPI=""
 S SAMEAS("URI")="NPI:"_NPI
 S SAMEAS("LABEL")=$P(^VA(200,IEN,0),"^")
 Q
 ;
 ;
 ; C*** Resolution
 ;
RESC(FILENUM,IEN,DEFLABEL,SAMEAS) ; 
 Q:((FILENUM="")!(IEN=""))
 I FILENUM="50" D RESC50(IEN,.SAMEAS) Q  ; DRUG
 I FILENUM="8252" D RESC8252(IEN,.SAMEAS) Q  ; NDC
 I FILENUM="8250" D RESC8250(IEN,.SAMEAS) Q  ; INS/HICL
 I FILENUM="8250.1" D RESC8250P1(IEN,.SAMEAS) Q  ; IN/HIC
 ; TOADD: 8251 CDC - need to reach back to NDC for name
 ; TOADD 8251.2 DF - not ref'ed in pgrafs but round out
 I FILENUM="8254.01" D RESC8254P01(IEN,.SAMEAS) Q  ; All Sel
 I FILENUM="8188" D RESC8188(IEN,.SAMEAS) Q  ; LOINC
 D RESCSTDS(FILENUM,IEN,DEFLABEL,.SAMEAS) Q:$D(SAMEAS("URI"))
 Q
 ;
 ;
 ; Drug 50 to NDC or NDDF CDC or local
 ; Proxy for CDC 
 ;
RESC50(IEN,SAMEAS) ; nddf:cdc
 S SAMEAS("URI")="LOCAL"
 N PNDCIEN S PNDCIEN=$P($Get(^PSDRUG(IEN,0)),"^",4)
 Q:PNDCIEN=""
 D RESC8252(PNDCIEN,.SAMEAS)
 Q:SAMEAS("URI")="LOCAL"
 N GCNSEQNO S GCNSEQNO=$P(^PSDFDB(8252,PNDCIEN,0),"^")
 Q:GCNSEQNO'=+GCNSEQNO
 Q:GCNSEQNO=0
 ; Pad the id to 6 + cdc extension for NDDF
 S SAMEAS("URI")="NDDF:"_"cdc"_$TR($J(GCNSEQNO,6)," ","0")
 ; Leave SAMEAS LABEL == NDC Label
 Q
 ;
 ;
 ; NDC - separate from other standards as reused
 ; ... not reducing to nddf cdc
 ;     
RESC8252(IEN,SAMEAS) ; NDC
 S:'$D(SAMEAS("URI")) SAMEAS("URI")="LOCAL"
 Q:'$D(^PSDFDB(8252,IEN,0))
 N NDCLBL S NDCLBL=$P(^PSDFDB(8252,IEN,0),"^",4)
 Q:NDCLBL=""
 ; NDC is IEN without -'s and leading 0's removed
 S SAMEAS("URI")="NDC:"_$TR($J(IEN,11)," ","0")
 S SAMEAS("LABEL")=NDCLBL
 Q
 ;
 ;
 ; INS (HICL) - 8250
 ;
RESC8250(IEN,SAMEAS) ; nddf:ins
 S:'$D(SAMEAS("URI")) SAMEAS("URI")="LOCAL"
 Q:'$D(^PSDFDB(8250,IEN,0))
 N LBL S LBL=$P(^PSDFDB(8250,IEN,0),"^")
 Q:LBL=""
 ; HICL (seq no) is IEN padded ie/ leading 0's back
 S SAMEAS("URI")="NDDF:ins"_$TR($J(IEN,6)," ","0")
 S SAMEAS("LABEL")=LBL
 Q
 ; 
 ;
 ; IN (HIC) 8250.1
 ;
RESC8250P1(IEN,SAMEAS) ; nddf:in
 S:'$D(SAMEAS("URI")) SAMEAS("URI")="LOCAL"
 Q:'$D(^PSDFDB(8250.1,IEN,0))
 N LBL S LBL=$P(^PSDFDB(8250.1,IEN,0),"^",2)
 Q:LBL=""
 ; IN is IEN padded ie/ leading 0's back
 S SAMEAS("URI")="NDDF:in"_$TR($J(IEN,6)," ","0")
 S SAMEAS("LABEL")=LBL
 Q
 ;
 ;
 ; Allergy Selection (8254.01)
 ; proxy for INS or DAC
 ;
 ; TOADD: selections that dress DACs 
 ;
RESC8254P01(IEN,SAMEAS) ; to nddf:ins
 ; No Q for LOCAL as valid to have no HICL
 Q:'$D(^PSDC(8254.01,IEN,0))
 N HICLIEN S HICLIEN=$P(^PSDC(8254.01,IEN,0),"^",3)
 ; Ex/ 8254_01-1160 (marked obsolete so!)
 Q:HICLIEN=""
 D RESC8250(HICLIEN,.SAMEAS)
 Q 
 ;
 ;
 ; LOINC - TOADD: link from 60
 ;
RESC8188(IEN,SAMEAS) ; LOINC
 S:'$D(SAMEAS("URI")) SAMEAS("URI")="LOCAL"
 Q:'$D(^DALOINC(8188,IEN,0))
 Q:'$D(^DALOINC(8188,IEN,1))
 N CODE S CODE=$P(^DALOINC(8188,IEN,0),"^")
 Q:CODE=""
 N LBL S LBL=$P(^DALOINC(8188,IEN,1),"^",3)
 Q:LBL=""
 S SAMEAS("URI")="LOINC:"_CODE
 S SAMEAS("LABEL")=LBL
 Q
 ;
 ;
 ; Standard files: 80 (ICDCM Diag), 80.1 (ICDCM Proc)
 ; 
 ; TOADD: 8171 (HPTC), 8151 (cpt/hcpcs)
 ;
RESCSTDS(FILENUM,IEN,DEFLABEL,SAMEAS) ;
 ; Can't default to LOCAL as this is the default
 I FILENUM="80" D
 . Q:'$D(@("^ICD9("_IEN_",0)"))
 . S SAMEAS("URI")="ICD9CM:"_$P(DEFLABEL,"/",2)
 . S SAMEAS("LABEL")=$P(@("^ICD9("_IEN_",0)"),"^",3)
 I FILENUM="80.1" D
 . Q:'$D(@("^ICD0("_IEN_",0)"))
 . S SAMEAS("URI")="ICD9CM:"_$P(DEFLABEL,"/",2)
 . S SAMEAS("LABEL")=$P(@("^ICD0("_IEN_",0)"),"^",4)
 Q
 ;
]]></Routine>


<Routine name="FMQLTEST" type="MAC" languagemode="0" timestamp="63152,36285.183428"><![CDATA[
 ;
 ; Basic Test for Query parser
 ;
QP ;
 N QUERY,PARAMS
 ; Two birds test: first op name is valid but rest isn't
 S QUERY="DESCRIBEX NONSENSE AND MORE"
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR="" W "0. "_QUERY_" - FAIL: NO EXPECTED ERROR",! Q
 W "0. "_QUERY_" - SUCCESS - "_ERROR,!
 S QUERY="SELECT 2"
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR'="" W "1. UNEXPECTED ERROR - "_ERROR,! Q
 I $G(PARAMS("OP"))'="SELECT" W "1. BAD OP",! Q
 I $G(PARAMS("TYPE"))'=2 W "1. BAD TYPE",! Q
 W "1. "_QUERY_" - SUCCESS",!
 S QUERY="DESCRIBE 2-1"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR'="" W "2. UNEXPECTED ERROR - "_ERROR,! Q
 I $G(PARAMS("OP"))'="DESCRIBE" W "2. BAD OP",! Q
 I $G(PARAMS("TYPE"))'=2 W "2. BAD TYPE",! Q
 I $G(PARAMS("ID"))'=1 W "2. BAD ID",! Q
 W "2. "_QUERY_" - SUCCESS",!
 S QUERY="SELECT 2 LIMIT 100 OFFSET 10"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR'="" W "3. UNEXPECTED ERROR - "_ERROR,! Q
 I $G(PARAMS("OP"))'="SELECT" W "3. BAD OP",! Q
 I $G(PARAMS("TYPE"))'=2 W "3. BAD TYPE",! Q
 I $G(PARAMS("LIMIT"))'=100 W "3. BAD LIMIT",! Q
 I $G(PARAMS("OFFSET"))'=10 W "3. BAD OFFSET",! Q
 W "3. "_QUERY_" - SUCCESS",!
 ; Non numeric LIMIT is an ERROR
 S QUERY="SELECT 2 LIMIT 100X"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR="" W "4. "_QUERY_" - FAIL: NO EXPECTED ERROR",! Q
 W "4. "_QUERY_" - SUCCESS - "_ERROR,!
 S QUERY="DESCRIBE 2-1 CSTOP 100"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR'="" W "5. UNEXPECTED ERROR - "_ERROR,! Q
 I $G(PARAMS("CNODESTOP"))'=100 W "5. CSTOP not parsed to I Name",! Q
 W "5. "_QUERY_" - SUCCESS",!
 ; No type or ID
 S QUERY="SELECT LIMIT 100"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR="" W "6. "_QUERY_" - FAIL: NO EXPECTED ERROR",! Q
 W "6. "_QUERY_" - SUCCESS - "_ERROR,!
 S QUERY="SELECT 2 LIMIT"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR="" W "7. "_QUERY_" - FAIL: NO EXPECTED ERROR",! Q
 W "7. "_QUERY_" - SUCCESS - "_ERROR,!
 S QUERY="SELECT TYPES"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR'="" W "8. UNEXPECTED ERROR - "_ERROR,! Q
 I $G(PARAMS("OP"))'="SELECT TYPES" W "8. OP not correct: "_$G(PARAMS("OP")),! Q
 W "8. "_QUERY_" - SUCCESS",!
 S QUERY="SELECT TYPES TOPONLY POPONLY"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR'="" W "9. UNEXPECTED ERROR - "_ERROR,! Q
 I $G(PARAMS("TOPONLY"))'=1 W "9. TOPONLY not set",! Q
 I $G(PARAMS("POPONLY"))'=1 W "9. POPONLY not set",! Q
 W "9. "_QUERY_" - SUCCESS",!
 S QUERY="DESCRIBE 63_04 IN 63-4 LIMIT 10"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR'="" W "9. UNEXPECTED ERROR - "_ERROR,! Q
 I $G(PARAMS("IN"))'="63-4" W "10. IN Not Taken",! Q
 I $G(PARAMS("TYPE"))'="63_04" W "10. TYPE Not Taken",! Q
 I $G(PARAMS("LIMIT"))'=10 W "10. LIMIT Not Taken",! Q
 W "10. "_QUERY_" - SUCCESS",!
 S QUERY="DESCRIBE TYPE 2"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR'="" W "11. UNEXPECTED ERROR - "_ERROR,! Q
 I $G(PARAMS("FOP"))'="DESCRIBE TYPE" W "11. OP Incorrect",! Q
 I $G(PARAMS("TYPE"))'=2 W "11. TYPE Wrong",! Q
 W "11. "_QUERY_" - SUCCESS",!
 ; Testing keyword inclusion in filter is taken care of
 S QUERY="SELECT 2 LIMIT 100 FILTER (.02=OFFSET) OFFSET 10"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR'="" W "12. UNEXPECTED ERROR - "_ERROR,! Q
 I $G(PARAMS("OP"))'="SELECT" W "12. BAD OP",! Q
 I $G(PARAMS("TYPE"))'=2 W "12. BAD TYPE",! Q
 I $G(PARAMS("LIMIT"))'=100 W "12. BAD LIMIT",! Q
 I $G(PARAMS("OFFSET"))'=10 W "12. BAD OFFSET",! Q
 I $G(PARAMS("FILTER"))'=".02=OFFSET" W "12. BAD FILTER",! Q
 W "12. "_QUERY_" - SUCCESS",!
 S QUERY="SELECT 2 LIMIT 100 FILTER(.02=2-9) OFFSET 10"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR'="" W "13. UNEXPECTED ERROR - "_ERROR,! Q
 I $G(PARAMS("FILTER"))'=".02=2-9" W "13. BAD FILTER",! Q
 W "13. "_QUERY_" - SUCCESS",!
 S QUERY="SELECT 2 FILTER(.02=2-9)"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR'="" W "14. UNEXPECTED ERROR - "_ERROR,! Q
 I $G(PARAMS("FILTER"))'=".02=2-9" W "14. BAD FILTER",! Q
 W "14. "_QUERY_" - SUCCESS",!
 S QUERY="SELECT 2 FILTER(.02=2-9"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR="" W "15. "_QUERY_" - FAIL: NO EXPECTED ERROR",! Q
 W "15. "_QUERY_" - SUCCESS - "_ERROR,!
 S QUERY="SELECT 2 FILTER .02=2-9)"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR="" W "16. "_QUERY_" - FAIL: NO EXPECTED ERROR",! Q
 W "16. "_QUERY_" - SUCCESS - "_ERROR,!
 W "17. DUMMY - to be filled in",!
 S QUERY="DESCRIBE BADTYPES"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR'="" W "18. UNEXPECTED ERROR - "_ERROR,! Q
 W "18. "_QUERY_" - SUCCESS",!
 S QUERY="COUNT _114 IN _11-.1102"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR'="" W "19. UNEXPECTED ERROR - "_ERROR,! Q
 I '$D(PARAMS("IN")) W "19. UNEXPECTED ERROR - NO 'IN' PARSED",! Q
 W "19. "_QUERY_" - SUCCESS",!
 S QUERY="SELECT 120_5 FILTER(.02=2-9&!bound(2)&.03=120_51-8)"
 K PARAMS
 S ERROR=$$PRSQUERY^FMQLQP(QUERY,.PARAMS)
 I ERROR'="" W "20. UNEXPECTED ERROR - "_ERROR,! Q
 ; Tries out Embedded )'s
 I PARAMS("FILTER")'=".02=2-9&!bound(2)&.03=120_51-8" W "20. UNEXPECTED ERROR - FILTER NOT PARSED PROPERLY",! Q
 W "20. "_QUERY_" - SUCCESS",!
 Q
 ;
]]></Routine>


<Routine name="FMQLUTIL" type="MAC" languagemode="0" timestamp="63260,32180.432532"><![CDATA[
FMQLUTIL ;CG/CD - Caregraf - FMQL Utilities; 07/12/2013  11:30
 ;;1.1a;FMQLQP;;Oct 30th, 2013
 ;
 ; FMQL Utilities
 ; 
 ; Schema and data array walkers and checkers
 ; 
 ; FMQL Query Processor (c) Caregraf 2010-2013 AGPL
 ;
 ;
 ;
 ; eXecute a routine, TOX (TO eXecute) on members of a file. Flexible - TOX
 ; can do anything from a straightforward exposure of file contents to 
 ; counting to aggregations of various kinds.
 ; - for both globals and cnodes
 ;   - IENA="" if GL - ie/ only set for CNODE
 ; - Controls position in file with LIMIT, OFFSET, AFTERIEN
 ; - PARAMS allows extra values to be passed to TOX
 ; - NOIDXMX = Maximum size of file to filter where no index exists. -1 means no max. This
 ;   matters for filters. You don't want to make a linear search of a huge file looking 
 ;   for a couple of entries. Note: not being set in MUMPS - upper bound set in Apache
 ; - Special case: ORDERBY - for now only on .01 if the B Index
 ;
XONFL(FLINF,FILTER,IENA,LIMIT,OFFSET,AFTERIEN,ORDERBY,NOIDXMX,TOX,PARAMS) ;
 N PLC,MFLT
 I AFTERIEN'="" S OFFSET=0  ; Ensure OFFSET off if AFTERIEN
 S PLC("LIMIT")=LIMIT,PLC("OFFLFT")=OFFSET,PLC("AFTERIEN")=AFTERIEN,PLC("CNT")=0
 ; Build filter expression
 S MFLT=$S(FILTER'="":"S MFTEST="_$$FLTTOM^FMQLFILT(.FLINF,FILTER,IENA),1:"")
 ; CNodes walk IENA.
 I '$D(FLINF("GL")) D XFAR(.FLINF,IENA,MFLT,.PLC,TOX,.PARAMS) Q PLC("CNT")
 ; Special case: ORDER BY .01 and BIDX supported
 I ORDERBY=".01",$D(FLINF("BIDX")) D XIDXA(.FLINF,FLINF("BIDX"),"",MFLT,.PLC,TOX,.PARAMS) Q PLC("CNT")
 ; Global but no filter - walk IENA
 I MFLT="" D XFAR(.FLINF,FLINF("ARRAY"),"",.PLC,TOX,.PARAMS) Q PLC("CNT")
 ; See if filter yields an IDXA(V)
 D FLTIDX^FMQLFILT(.FLINF,FILTER,.IDXA,.IDXSTART)
 ; 5 Cases:
 ; - a. non > filter gives IDXAV (IDXSTART="")
 I $G(IDXA)'="",$G(IDXSTART)="" D XIDXAV(.FLINF,IDXA,MFLT,.PLC,TOX,.PARAMS) Q PLC("CNT")
 ; - b. > filter gives IDXA (IDXSTART'="")
 I $G(IDXA)'="" D XIDXA(.FLINF,IDXA,IDXSTART,MFLT,.PLC,TOX,.PARAMS) Q PLC("CNT")
 ; - c. manual IDXA (100,52). Use XIDXA non leaf indexes. No MFLT
 D MFLTIDX^FMQLFILT(.FLINF,FILTER,.IDXA,.IDXSTART)
 I $G(IDXA)'="" D XIDXA(.FLINF,IDXA,"","",.PLC,TOX,.PARAMS) Q PLC("CNT")
 ; - d. No IDXA(V) but filter. See if file too big to filter
 I NOIDXMX'=-1,($S($D(FLINF("FMSIZE")):FLINF("FMSIZE")>NOIDXMX,1:1)) Q -1
 ; - e. file not to big to filter, row by row
 D XFAR(.FLINF,FLINF("ARRAY"),MFLT,.PLC,TOX,.PARAMS)
 Q PLC("CNT")
 ;
 ;
 ; Apply TOX on entries in a simple IEN Array
 ; 
 ; Used for plain walks of files in IEN order, for contained node walks and 
 ; for non-indexed filtering of smaller files.
 ;
XFAR(FLINF,FAR,MFLT,PLC,TOX,PARAMS) ;
 N AIEN,IEN,MFTEST
 ; Assumption: OFFLFT=0 if AFTERIEN as it takes precedence
 S AIEN=$S($D(PLC("AFTERIEN")):PLC("AFTERIEN"),1:0)
 S IEN=AIEN F  S IEN=$O(@FAR@(IEN)) Q:IEN'=+IEN!(PLC("CNT")=PLC("LIMIT"))  D
 . Q:($P($G(@FAR@(IEN,0)),"^")="")  ; All must have .01 value
 . I MFLT'="" X MFLT Q:'MFTEST  ; Quit if filter fails
 . I PLC("OFFLFT")>0 S PLC("OFFLFT")=PLC("OFFLFT")-1 Q  ; Quit if not at offset
 . S PLC("CNT")=PLC("CNT")+1
 . X TOX  ; Takes .FLINF, IEN, FAR (for CNodes), PARAMS (extras)
 Q
 ;
 ;
 ; An IDX Value Array (IDXAV) is more involved than a simple IEN array
 ; - IDX's can embed alias' ex/ ^DPT("B",NAME,IEN,"X")=1
 ; - IENs may not be in the leaf/last position
 ; and though we walk the IDXAV, we apply TOX to the global
 ; 
 ; Directly for = filters where the predicate asserted is indexed. Key 
 ; for efficiently traversing the graph arrangements (Vital points to Patient)
 ; 
XIDXAV(FLINF,IDXAV,MFLT,PLC,TOX,PARAMS) ;
 N FAR,AIEN,IEN,MFTEST
 I '$D(FLINF("GL")) Q -1  ; globals only, CNodes walked in XFAR 
 S FAR=FLINF("ARRAY")  ; FAR != IDXAV
 ; Assumption: OFFLFT=0 if AFTERIEN as it takes precedence
 S AIEN=$S($D(PLC("AFTERIEN")):PLC("AFTERIEN"),1:0)
 I '$D(PLC("LIEN")) S PLC("LIEN")=AIEN
 S IEN=AIEN F  S IEN=$O(@IDXAV@(IEN)) Q:IEN'=+IEN!(PLC("CNT")=PLC("LIMIT"))  D
 . Q:IEN=PLC("LIEN")  ; Traverse above leaves means same IEN > once in order
 . S PLC("LIEN")=IEN  ; Need to track across walks if 2 step IDXA
 . Q:$G(@IDXAV@(IEN))'=""  ; Skip all aliases. Aliases appear out of order
 . Q:($P($G(@FAR@(IEN,0)),"^")="")  ; All must have .01 value
 . I MFLT'="" X MFLT Q:'MFTEST  ; Quit if filter fails
 . I PLC("OFFLFT")>0 S PLC("OFFLFT")=PLC("OFFLFT")-1 Q  ; Quit if not at offset
 . S PLC("CNT")=PLC("CNT")+1
 . X TOX  ; Takes .FLINF, IEN, FAR (for CNodes), PARAMS (extras)
 Q
 ;
 ;
 ; IDX Array traversal is a two stepper: walk the array in value order and
 ; step down into the value arrays.
 ;
 ; Used for > filters and ORDERBY (which is equivalent to > "") 
 ;
XIDXA(FLINF,IDXA,IDXSTART,MFLT,PLC,TOX,PARAMS) ;
 N IDXV,IDXVA
 S IDXV=IDXSTART F  S IDXV=$O(@IDXA@(IDXV)) Q:IDXV=""  D
 . S IDXVA=$NA(@IDXA@(IDXV))
 . D XIDXAV(.FLINF,IDXVA,MFLT,.PLC,TOX,.PARAMS)
 Q
 ;
 ;
 ; File's are globals (T files) or subfiles (S files)
 ;
BLDFLINF(FILE,FLINF) ;
 S FILE=$TR(FILE,"_",".")
 S FLINF("FILE")=FILE
 S FLINF("EFILE")=$TR(FILE,".","_")
 I '$D(^DD(FILE)) S FLINF("BAD")="No such file" Q
 I '$D(^DD(FILE,.01,0)) S FLINF("BAD")=".01 corrupt" Q
 ; Note 1 field for Multiple means list element
 N FIELD,NOFIELDS
 S FIELD=0,NOFIELDS=0 F  S FIELD=$O(^DD(FILE,FIELD)) Q:FIELD'=+FIELD  S NOFIELDS=NOFIELDS+1
 I NOFIELDS=0 S FLINF("BAD")="No fields" Q
 S FLINF("NOFIELDS")=NOFIELDS
 I $D(^DIC(FILE,0,"GL")) D BLDTFINF(FILE,.FLINF) Q
 I $G(^DD(FILE,0,"UP"))'="" D BLDSFINF(FILE,.FLINF) Q
 S FLINF("BAD")="No global or multiple definition"
 Q
 ;
 ;
 ; Top File Info
 ; Fields: ARRAY, BIDX, FILE, FLAGS, FMSIZE, GL, LABEL
 ;
BLDTFINF(FILE,FLINF) ;
 I $G(^DIC(FILE,0))="" S FLINF("BAD")="^DIC 0 Has No Data" Q
 S FLINF("GL")=^DIC(FILE,0,"GL")
 ; Handle ^DPT( and ^GMR(120.5,
 S FLINF("ARRAY")=$E(FLINF("GL"),1,$L(FLINF("GL"))-1)
 I FLINF("ARRAY")["(" S FLINF("ARRAY")=FLINF("ARRAY")_")"
 ; S FLINF("ARRAY")=$TR(FLINF("GL"),",",")")
 I '$D(@FLINF("ARRAY")@(0)) S FLINF("BAD")="No 0 Entry for Array" Q
 S FLHDR=@FLINF("ARRAY")@(0)
 I $P(FLHDR,"^")="" S FLINF("BAD")="No Name" Q
 ; TODO: have just LABEL. Do non native changes above this.
 ; S FLINF("LABEL")=$TR($P(FLHDR,"^"),"/","_")  ; alt is ^DD(FILE,0,"NM")
 S FLINF("LABEL")=$P(FLHDR,"^")
 S FLINF("FLAGS")=$P(FLHDR,"^",2)
 ; don't always have size
 I $P(FLHDR,"^",4) S FLINF("FMSIZE")=+$P(FLHDR,"^",4)
 I $P(FLHDR,"^",3) S FLINF("LSTIEN")=$P(FLHDR,"^",3)
 ; Version information
 S:$D(^DD(FILE,0,"VR")) FLINF("VERSION")=^DD(FILE,0,"VR")
 S:$D(^DD(FILE,0,"VRPK")) FLINF("VPACKAGE")=^DD(FILE,0,"VRPK")
 ; Not sending VRRV as formats vary - ex/ 80 vs 798.1
 I $D(^DIC(FILE,"%",1))  D  ; APP GROUPS
 . S APGSVAL=""
 . S I=0 F  S I=$O(^DIC(FILE,"%",I)) Q:I'=+I  D 
 . . I APGSVAL'="" S APGSVAL=APGSVAL_";"
 . . S APGSVAL=APGSVAL_^DIC(FILE,"%",I,0)
 . . Q
 . S FLINF("APPGRPS")=APGSVAL
 ; I $D(@FLINF("ARRAY")@("B")) S FLINF("BIDX")=FLINF("GL")_"""B"")"
 ; S:$P($G(@FLINF("ARRAY")@(.01,1,1,0)),"^",2)="B" FLINF("BIDX")=FLINF("GL")_"""B"")"
 S:$$FIELDIDX(FILE,".01")="B" FLINF("BIDX")=FLINF("GL")_"""B"")"
 ; # of fields is: $P(^DD(FILE,0),"^",0)
 Q
 ;
 ;
 ; Sub or contained file Info
 ; Most (all?) sub file's named in files ie. 120_81 inside 120_8 but can't 
 ; key off that.
 ; FIELDS: FILE, LABEL, PARENT, PFIELD, PLOCSUBS
 ;
BLDSFINF(FILE,FLINF) ;
 ; Ex/ ^DD(8925.02,.01,0)="REPORT TEXT^W^^0;1^Q"
 ; Used '$$VFILE^DILFD(FILE) elsewhere to same effect
 ; WP is a file (has DD entry) but not considered a file for FMQL
 I $P($G(^DD(FILE,.01,0)),"^",2)["W" S FLINF("BAD")="WP FILE" Q
 I '$D(^DD(FILE,0,"NM")) S FLINF("BAD")="No Name" Q
 S FLINF("LABEL")=$O(^DD(FILE,0,"NM",""))
 S FLINF("PARENT")=^DD(FILE,0,"UP")
 ; TODO: check slow down but needed to get at Subfile Array anyhow
 N PFLINF D BLDFLINF(FLINF("PARENT"),.PFLINF)
 I $D(PFLINF("BAD")) S FLINF("BAD")="Corrupt Parent: "_PFLINF("BAD") Q
 I '$D(^DD(FLINF("PARENT"),"SB",FILE)) S FLINF("BAD")="Parent doesn't know this multiple" Q
 ; Get Field by Sub File id and not by sub file label in "B"
 S FLINF("PFIELD")=$O(^DD(FLINF("PARENT"),"SB",FILE,""))  ; SubFile location in parent
 I '$D(^DD(FLINF("PARENT"),FLINF("PFIELD"),0)) S FLINF("BAD")="Multiple doesn't know parent's field for it" Q
 S PLOCPOS=$P(^DD(FLINF("PARENT"),FLINF("PFIELD"),0),"^",4)
 I PLOCPOS="" S FLINF("BAD")="No location information" Q
 I $P(PLOCPOS,";",2)'="0" S FLINF("BAD")="Multiple not in position 0" Q
 S FLINF("PLOCSUB")=$P(PLOCPOS,";")
 Q
 ;
 ;
 ; Field Info
 ; Fields: FIELD, FLAGS, LABEL, LOCPOS, LOCSUB, TYPE
 ; Specials fields: CODES (for type 3)
 ; 
 ; TODO: 
 ; - Careful: gfs_frm.htm not definite. Ex/ "S" in flags if multiple with only
 ; one field, a set of codes (ex/ 120.506S for ^DD(120.5,4,0)
 ; - Computed (C) is DC,BC,C,Cm,Cmp. Must distinguish actual type. Correlate with no location
 ; - move inputTransform in here from Sch serializer. Want for filter processing
 ; - move IDX in here from Sch serializer: want for filters
 ; - Add ^DD(FILE,FIELD,1,1,...)
 ;
BLDFDINF(FLINF,FIELD,FDINF) ;
 N FILE S FILE=FLINF("FILE")
 S FIELD=$TR(FIELD,"_",".")
 S FDINF("FIELD")=FIELD
 I '$D(^DD(FILE,FIELD,0)) S FDINF("BAD")="No 0 Definition: "_FILE_"/"_FIELD Q
 N FLAGS S FLAGS=$P(^DD(FILE,FIELD,0),"^",2)
 S FDINF("FLAGS")=FLAGS
 S FDINF("LABEL")=$P(^DD(FILE,FIELD,0),"^")
 ; Pred: use in XML fields/RDF and JSON. TODO: account for name reuse
 S FDINF("PRED")=$$FIELDTOPRED(FDINF("LABEL"))
 ; Date/Number/Codes/String/WP String/Pointer/V Pointer/MULT/MUMPS
 ; TBD: Computed - B, m, D
 I +FLAGS D  ; WP and MULT both refer to subfile in flags.
 . I $P($G(^DD(+FLAGS,.01,0)),"^",2)["W" S FDINF("TYPE")=5
 . E  S FDINF("TYPE")=9 S FDINF("SUBFILE")=+FLAGS  ; TBD: validate ["M ?
 ; TBD: Default String even if no "F". Should log.
 E  D
 . ; .001 in FM is IEN - may be more than a # ie/ a date or a pointer
 . S FDINF("TYPE")=$S(FIELD=.001:11,FLAGS["D":1,FLAGS["N":2,FLAGS["S":3,FLAGS["F":4,FLAGS["C":6,FLAGS["P":7,FLAGS["V":8,FLAGS["K":10,1:"4") ; Default to String
 . ; N IDX S IDX=$$FIELDIDX^FMQLUTIL(FILE,FIELD)
 . ; S:IDX'="" FDINF("IDX")=IDX
 . D BLDCREFS(FILE,FIELD,.FDINF)
 ; TODO: this BAD is never reached as type defaults to String
 I FDINF("TYPE")="" S FDINF("BAD")="No type set: "_FILE_"/"_FIELD Q
 ; In VistA, Access, Verify in file 200 are not always encrypted (C*** encrypts its equivalents). Explicitly mark as sensitive.
 I FILE=200,((FIELD=2)!(FIELD=11)) S FDINF("HIDE")="SENSITIVE"
 I '((FDINF("TYPE")=6)!(FDINF("TYPE")=11)) D
 . S FDLOC=$P(^DD(FILE,FIELD,0),"^",4)
 . S FDINF("LOC")=FDLOC
 . S FDINF("LOCSUB")=$P(FDLOC,";")
 . ; Check for " ; "? ie. spaces even though field not given as computed
 . I $TR(FDINF("LOCSUB")," ")="" S FDINF("BAD")="Corrupt location: "_FILE_"/"_FIELD Q
 . ; Position of 9 is 1 but that's meaningless. Leave out position.
 . I FDINF("TYPE")'=9 D
 . . N LOCWHERE S LOCWHERE=$P(FDLOC,";",2)
 . . I LOCWHERE="" S FDINF("BAD")="No location position: "_FILE_"/"_FIELD Q
 . . ; Extract form for 63/.1 (E1,19) or 68/.1;E1,220 (limit for screenman?)
 . . I LOCWHERE?1"E"1.N1","1.N S FDINF("LOCE")=$E(LOCWHERE,1,$L(LOCWHERE)) Q
 . . I LOCWHERE=+LOCWHERE S FDINF("LOCPOS")=LOCWHERE Q
 . . ; TBD: is there another position type? Return an error until I support it.
 . . S FDINF("BAD")="Unsupported location position: "_FILE_"/"_FIELD_":"_LOCWHERE Q
 I FDINF("TYPE")=3 D 
 . ; Exposes codes as either Enums or Booleans
 . N CODES,UCODES,C,MN,CLABEL
 . S CODES=$P(^DD(FILE,FIELD,0),"^",3)
 . S UCODES=$TR(CODES,"yesno","YESNO") ; Yes to YES, No to NO
 . ; Boolean if 2 values Y:YES;N:NO etc.
 . I $L(UCODES,";")=3,((UCODES["Y:YES;"&(UCODES["N:NO;"))!(UCODES["Y:Y;"&(UCODES["N:N;"))!(UCODES["1:YES;"&(UCODES["0:NO;"))!(UCODES["1:Y;"&(UCODES["0:N;"))) S FDINF("TYPE")=12
 . ; or Boolean if 1 value Y:YES etc or name of field is name of value
 . ; label check is simple: won't catch "X Flag"/"1:X" etc.
 . E  I $L(UCODES,";")=2,((UCODES="1:"_FDINF("LABEL")_";")!(UCODES="Y:YES;")!(UCODES="N:NO;")!(UCODES="Y:Y;")!(UCODES="N:N;")!(UCODES="1:YES;")!(UCODES="0:NO;")!(UCODES="1:Y;")!(UCODES="0:N;")) S FDINF("TYPE")=12
 . F C=1:1 Q:$P(CODES,";",C)=""  D
 . . S MN=$P($P(CODES,";",C),":")
 . . S CLABEL=$P($P(CODES,";",C),":",2)
 . . I FDINF("TYPE")=12 S FDINF("CODES",MN)=$S(MN["1"!(MN["Y"):"true",FDINF("LABEL")=CLABEL:"true",1:"false") Q
 . . S FDINF("CODES",MN)=CLABEL
 . . Q
 . Q
 I FDINF("TYPE")=7 S FDINF("PFILE")=+$P(FLAGS,"P",2) Q
 ; .001 can be a P(ointer), D(ate), F(string), N(numeric)
 I FDINF("TYPE")=11,FLAGS["P" S FDINF("PFILE")=+$P(FLAGS,"P",2) Q
 I FDINF("TYPE")=9 S FDINF("BFILE")=+FLAGS Q
 I FDINF("TYPE")=8 D
 . I '$D(^DD(FILE,FIELD,"V")) S FDINF("BAD")="No VPTR Definition: "_FILE_"/"_FIELD Q
 . S X=0 F  S X=$O(^DD(FILE,FIELD,"V",X)) Q:X'=+X  D
 . . N PFILE S PFILE=$P(^DD(FILE,FIELD,"V",X,0),"^",1)
 . . I '$D(^DIC(PFILE,0,"GL")) S FDINF("BAD")="No Global for VPTR target: "_PFILE Q
 . . N PLOC S PLOC=^DIC(PFILE,0,"GL")
 . . S FDINF("PLOC",PLOC)=PFILE
 . . S FDINF("PFILE",PFILE)=PLOC
 Q
 ;
 ;
 ; Get first non-mumps index for a field.
 ; TBD: check ^DD(FILE,"IX",FIELD) - compare to walk below
 ; TBD: support .11 ie. Walk its ^DD("IX","B",FILE#) or ? ie. XREFs defined outside file. Equivalent of DESRIBE _11 FILTER(.01=[FILE]&&.2=R) and look at fields. Will need to distinguish .11 INDEX from Simple like B. Use array.
 ; 
 ; TODO: remove use of this and rely on CREF util below to fill in FDINF
 ;
FIELDIDX(FILE,FIELD) ;
 N IDXID,IDXINF,IDX
 I FILE=8927.1,FIELD=.01 Q "B" ; Missing from TIU TEMPLATE FIELD ^DD
 S IDX=""
 ; From '$D(^DD(FILE,FIELD,1))
 I '$D(^DD(FILE,FIELD,1,1)) Q ""  ; indexes number 1 up
 S IDXID=0 F  S IDXID=$O(^DD(FILE,FIELD,1,IDXID)) Q:((IDXID'=+IDXID)!(IDX'=""))  D  ; > 0 has indexes
 . Q:'$D(^DD(FILE,FIELD,1,IDXID,0))  ; TBD Corruption note
 . S IDXINF=^DD(FILE,FIELD,1,IDXID,0)
 . I $P(IDXINF,"^",3)'="MUMPS" S IDX=$P(^DD(FILE,FIELD,1,IDXID,0),"^",2) Q
 Q IDX
 ;
 ; 
 ; Fill in FLD CROSS REF INFO
 ;
 ; Get IDX, TRIGGERs and total number of CREFS of a field. Peer of MUMPS Cross References.
 ; 
 ; TODO: move 100, 52 MUMPS special IDX in here
 ;
BLDCREFS(FILE,FIELD,FDINF) ;
 N IDXID,IDXINF,IDXTYP
 I FILE=8927.1,FIELD=.01 S FDINF("IDX")="B" ; Missing from TIU TEMP FLD ^DD
 I '$D(^DD(FILE,FIELD,1,1)) Q
 S IDXID=0 F  S IDXID=$O(^DD(FILE,FIELD,1,IDXID)) Q:IDXID'=+IDXID  D
 . Q:'$D(^DD(FILE,FIELD,1,IDXID,0))
 . S FDINF("CREFNO")=$S($D(FDINF("CREFNO")):FDINF("CREFNO")+1,1:1)
 . S IDXINF=^DD(FILE,FIELD,1,IDXID,0)
 . S IDXTYP=$P(IDXINF,"^",3)
 . I IDXTYP="",'$D(FDINF("IDX")) S FDINF("IDX")=$P(^DD(FILE,FIELD,1,IDXID,0),"^",2) Q
 . Q:IDXTYP'="TRIGGER"
 . S TRIGFILE=$P(IDXINF,"^",4)
 . S TRIGFLD=$P(IDXINF,"^",5)
 . I $D(FDINF("TRIGS")) S FDINF("TRIGS")=FDINF("TRIGS")_","
 . E  S FDINF("TRIGS")=""
 . S FDINF("TRIGS")=FDINF("TRIGS")_$P(IDXINF,"^",4)_"/"_$P(IDXINF,"^",5)
 Q
 ;
 ;
 ; Get External Value
 ; TBD: get vptr
 ; TBD: GETS maps some .01's (50_605 to field 1 etc.) Is this in meta or ?
 ; Another ex is 120_8 Allergy Type is a 4 but treated like a CODE. Ext form
 ; comes from ^DD(120.8,3.1,2.1)="S Y=$$OUTTYPE^GMRAUTL(Y)" [this doesn't work
 ; for lab's name map.]
 ; TBD: catch the invalid - CODES beyond range, bad ptrs, dates etc.
 ;
GETEVAL(FDINF,IVAL) ;
 Q:$D(FDINF("HIDE")) "**HIDDEN**"
 Q:FDINF("TYPE")=1 $$MAKEXMLDATE^FMQLUTIL(IVAL)
 ; If coded value is out of schema's range will fall back to literal
 I ((FDINF("TYPE")=3)!(FDINF("TYPE")=12)),$D(FDINF("CODES",IVAL)) Q FDINF("CODES",IVAL)
 N EVAL S EVAL=IVAL ; Fallback to internal value
 I FDINF("TYPE")=7 D
 . I IVAL="0" Q  ; TODO NULL value that doesn't resolve (consider leaving out PTR)
 . N PFLINF D BLDFLINF(FDINF("PFILE"),.PFLINF)
 . Q:$D(PFLINF("BAD"))
 . N PFDINF D BLDFDINF(.PFLINF,.01,.PFDINF)
 . Q:$D(PFDINF("BAD"))
 . Q:$G(@PFLINF("ARRAY")@(IVAL,0))=""  ; Invalid Pointer
 . S IVAL=$P(@PFLINF("ARRAY")@(IVAL,0),"^")
 . Q:IVAL=""
 . S EVAL=$$GETEVAL(.PFDINF,IVAL)
 ; VPTR very like PTR - once PFILE is know.
 I FDINF("TYPE")=8 D
 . N PLOC S PLOC="^"_$P(IVAL,";",2)
 . Q:'$D(FDINF("PLOC",PLOC))  ; TBD: catch the buggy ptr instead
 . N PFILE S PFILE=FDINF("PLOC",PLOC)
 . N PFLINF D BLDFLINF(PFILE,.PFLINF)
 . Q:$D(PFLINF("BAD"))
 . N PID S PID=$P(IVAL,";")
 . Q:PID=""
 . Q:$G(@PFLINF("ARRAY")@(PID,0))=""  ; Invalid Pointer
 . N PFDINF D BLDFDINF(.PFLINF,.01,.PFDINF)
 . Q:$D(PFDINF("BAD"))
 . N PIVAL S PIVAL=$P(@PFLINF("ARRAY")@(PID,0),"^")
 . Q:PIVAL=""
 . S EVAL=$$GETEVAL(.PFDINF,PIVAL)
 Q EVAL
 ;
 ;
 ; Parse URL
 ; TBD: CNode - S PFILE=$G(^DD(FILE,0,"UP")) Q:'PFILE . Without this
 ; can't do recursive INs or DESCRIBE ONE of CNode.
 ; 
PARSEURL(URL,FLINF,ID) ;
 N FILE S FILE=$P(URL,"-")
 D BLDFLINF(FILE,.FLINF)
 I $D(FLINF("BAD")) Q
 S ID=$P(URL,"-",2) ; TBD: support CNode Identification
 Q
 ;
 ;
 ; Form: YYMMDD.HHMMSS but no trailing 0's ie 3 not 03 for hour if no minutes
 ;
MAKEXMLDATE(FMDATE) ;
 N XMLDATE
 S XMLDATE=(+$E(FMDATE,1,3)+1700)
 Q:$L(FMDATE)<4 XMLDATE_"-00-00T00:00:00Z"
 S XMLDATE=XMLDATE_"-"_$S($E(FMDATE,5)="":"0"_$E(FMDATE,4),1:$E(FMDATE,4,5))
 Q:$L(FMDATE)<6 XMLDATE_"-00T00:00:00Z"
 S XMLDATE=XMLDATE_"-"_$S($E(FMDATE,7)="":"0"_$E(FMDATE,6),1:$E(FMDATE,6,7))_"T"
 Q:$L(FMDATE)<9 XMLDATE_"00:00:00Z"
 S XMLDATE=XMLDATE_$S($E(FMDATE,10)="":"0"_$E(FMDATE,9),1:$E(FMDATE,9,10))_":"
 Q:$L(FMDATE)<11 XMLDATE_"00:00Z"
 S XMLDATE=XMLDATE_$S($E(FMDATE,12)="":"0"_$E(FMDATE,11),1:$E(FMDATE,11,12))_":"
 Q:$L(FMDATE)<13 XMLDATE_"00Z"
 S XMLDATE=XMLDATE_$S($E(FMDATE,14)="":"0"_$E(FMDATE,13),1:$E(FMDATE,13,14))_"Z"
 Q XMLDATE
 ;
 ;
 ; XMLDATE: YYYY-MM-DDTHH:MM:SSZ
 ; Note: over current RPC, will be YYYY-MM-DDTHH-MM-SSZ but
 ; behaves the same as not validating separators below.
 ; TBD: validate date contents correct (see X ^DD(DD) etc)
 ; Possible Issue: 2010-02 -> ...2, not ...02 in FileMan. 
 ; There may be month-only dates in FileMan and in this case,
 ; 3102 ie/ first month of 2010 will be less (numerically)
 ; than 310100. But month-wise it is more. In effect, month
 ; only or year only dates need per file example handling.
 ;
MAKEFMDATE(XMLDATE) ;
 N FMDATE
 ; If missing month or day, then pad with 0s
 S FMDATE=(+$E(XMLDATE,1,4)-1700)
 Q:$L(XMLDATE)<7 FMDATE_"0000"
 S FMDATE=FMDATE_$E(XMLDATE,6,7)
 Q:$L(XMLDATE)<10 FMDATE_"00"
 S FMDATE=FMDATE_$E(XMLDATE,9,10)
 Q:$E(XMLDATE,11)'="T" FMDATE
 S FMDATE=FMDATE_"."
 ; If trailing info missing, ok as $E returns "". 
 ; Does mean will accept 3 for 03 which isn't correct XML
 S FMDATE=FMDATE_$E(XMLDATE,12,13)
 S FMDATE=FMDATE_$E(XMLDATE,15,16)
 S FMDATE=FMDATE_$E(XMLDATE,18,19)
 Q FMDATE
 ;
 ;
 ; Predicate is lower alphanum and _
 ;
FIELDTOPRED(FIELD) ;
 SET ALW="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ /"
 SET UPC="ABCDEFGHIJKLMNOPQRSTUVWXYZ /"
 SET LOC="abcdefghijklmnopqrstuvwxyz__"
 S PRED=$TR($TR(FIELD,$TR(FIELD,ALW)),UPC,LOC)
 Q PRED
 ;
]]></Routine>


<Class name="CHCS.FMQL">
<Description>
CHCS.FMQL</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%SOAP.WebService</Super>
<TimeChanged>63238,25332.886971</TimeChanged>
<TimeCreated>62931,41492.007321</TimeCreated>

<Parameter name="SERVICENAME">
<Description>
FileMan Query Language (FMQL) for CHCS.</Description>
<Default>Query</Default>
</Parameter>

<Parameter name="NAMESPACE">
<Default>http://chcs.com/</Default>
</Parameter>

<Parameter name="USECLASSNAMESPACES">
<Description>
Namespaces of referenced classes will be used in the WSDL.</Description>
<Default>1</Default>
</Parameter>

<Method name="Query">
<Description>
Query</Description>
<FormalSpec>query:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<WebMethod>1</WebMethod>
<Implementation><![CDATA[
 Set U="^",DT=$ZDate($Horolog,8)-17000000
 Do FMQLRPC^FMQLQP(.out,query)
 Set ii="" For  Set ii=$Order(@out@(ii)) Quit:ii=""  Write @out@(ii)
 Kill @out
 Quit query
]]></Implementation>
</Method>

</Class>

<CSP name="FMQL.csp" application="/csp/fmquery/"><![CDATA[
<script language="Cache" method="OnPreHTTP" arguments="" returntype="%Boolean">
 Set %response.ContentType="application/json"
 Quit 1
</script>

<script language=CACHE runat=server>
 s $ztrap="^%ET"
 Set connect=##class(CHCS.FMQL).%New()
 Do connect.Query($Get(%request.Data("query",1)))
</script>]]></CSP>

</Export>
